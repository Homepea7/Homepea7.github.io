<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++常见输入输出的小总结</title>
    <url>/2020/29.IO-Stream/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>怎么说呢，首先说说地址，还是<a href="https://ac.nowcoder.com/acm/contest/5650?from=hr_test#question" target="_blank" rel="noopener">牛客网</a>。总地来说吧，最近也是做了不少的题目，对于输入和输出数据的类型东西也是有了一些了解。我最开始利用输入字符串的形式，加上 vector 解析的<a href="http://localhost:4000/2020/23.GetData-C/" target="_blank" rel="noopener">例子</a>也是一个不错的想法，但是最近仔细的做了一系列的输入输出题目以后，发现有了新的思路。</p>
<h1 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h1><p>废话不多说，直接上题，题型全是计算A+B的类型，具体如下：</p>
<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/A" target="_blank" rel="noopener">1. 题目描述</a></strong><br>计算a+b</p>
<p><strong>输入描述:</strong><br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据包括多组。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<p>一个简单的EOF，判断是否结束，比较简单直接贴答案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	<span class="keyword">while</span>(scanf(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF)</span><br><span class="line">		cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/B" target="_blank" rel="noopener">2. 题目描述</a></strong><br>计算a+b</p>
<p><strong>输入描述:</strong><br>输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)<br>接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9)<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 5</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<p>这个应该是最简单的一类了，直接上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, a, b;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= 0)	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i = 0; i &lt; n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/C" target="_blank" rel="noopener">3. 题目描述</a></strong><br>计算a+b</p>
<p><strong>输入描述:</strong><br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 5</span><br><span class="line">10 20</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<p>这个直接判断输入的数据，直接上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a, b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span>((a == 0) &amp;&amp; (b == 0))	</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/D" target="_blank" rel="noopener">4. 题目描述</a></strong><br>计算一系列数的和</p>
<p><strong>输入描述:</strong><br>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>这个直接判断输入第一个数即可，跟上面几乎没有区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, a, b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp = 0, sum = 0;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= 0)	</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			sum += tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/E" target="_blank" rel="noopener">5. 题目描述</a></strong><br>计算一系列数的和</p>
<p><strong>输入描述:</strong><br>输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>贴答案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t, n, a, b;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">if</span>(t &lt;= 0)	<span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i = 0; i &lt; t; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp = 0, sum = 0;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= 0)	<span class="built_in">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int j = 0; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			sum += tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/F" target="_blank" rel="noopener">6. 题目描述</a></strong><br>计算一系列数的和</p>
<p><strong>输入描述:</strong><br>输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 1 2 3 4</span><br><span class="line">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>同上，添加一个EOF，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n = 0;</span><br><span class="line">	<span class="keyword">while</span>(scanf(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		int sum = 0, tmp = 0;</span><br><span class="line">		<span class="keyword">for</span>(int i = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			sum += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://ac.nowcoder.com/acm/contest/5650/G" target="_blank" rel="noopener">6. 题目描述</a></strong><br>计算一系列数的和</p>
<p><strong>输入描述:</strong><br>输入数据有多组, 每行表示一组输入数据。</p>
<p>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。<br>示例示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5</span><br><span class="line">0 0 0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong><br>输出a+b的结果。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这个就是我最先开始说的输入问题，我最先使用的输入字符串然后去解析的方式实在很笨，看了一些帖子以后发现scanf的标准输入输出非常好用，在输入的信息的时候scanf会默认用空格或者换行来区分数据，因此直接强行判断即可，题目默认也是一个数字一个字符，碰到换行符’\n’就输出并且清空就行，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int  n, sum = 0;</span><br><span class="line">	char c;</span><br><span class="line">	<span class="keyword">while</span>(scanf(<span class="string">"%d%c"</span>, &amp;n, &amp;c) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += n;</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'\n'</span>)</span><br><span class="line">			cout &lt;&lt; sum &lt;&lt; endl, sum = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于笔试的刷题，我觉得<a href="https://ac.nowcoder.com/acm/contest/5650?from=hr_test#question" target="_blank" rel="noopener">牛客的这个帖子</a>是必做的，题目虽然不难，但是真的是受益匪浅！！！！</p>
]]></content>
      <categories>
        <category>The C/CPP language</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>C++大数取余和快速幂</title>
    <url>/2020/28.Big-number/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近遇到的一些笔试问题，关于大数的情况还是很多，因此在这里做一个小的说明，关于大数取余的过程，典型的运算就是幂！</p>
<h1 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a>大数取模</h1><p>一般而言，取模的数字是1000000007（一般也会写作1e9+7，一共十位数），对于这个数的一些问题，我只能做一个小的总结吧，有很多的数学解释我在后面就直接放链接了。</p>
<p>首先我觉得他是一个质数，而且足够大，因此在计算的时候不会很多麻烦，取余也比较方便；<br>其次int32的最大值是2147483647，所以对于int32位来说1000000007足够大；<br>最后int64的最大值是2^63-1，对于1000000007来说它的平方不会在int64中溢出 所以在大数相乘的时候，因为(a∗b) % c=((a%c) ∗ (b%c)) % c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。</p>
<p>这句话在做题的时候看上去只需要取模就可以了，但是在实际计算中还是有一些小坑，因此还是小小总结一下。</p>
<h1 id="关于快速幂"><a href="#关于快速幂" class="headerlink" title="关于快速幂"></a>关于快速幂</h1><p>快速幂运算其实就是二分法。假设要求x^n，如果n = 2^k，那么原题可以很轻松的表示为：x^n = ((x^2)^2)^2…。这样只要做k次平方运算就能解决，时间复杂度就从O(n)下降到log(n)。<br>示例代码如下（中间还做了大数取余的过程）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">long long mod(long long a, long long b) &#123;</span><br><span class="line">	long long ans = 1;</span><br><span class="line">	long long c = 1000000007;</span><br><span class="line">	<span class="keyword">while</span>(b &gt; 0) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; 1) ans = ans * a % c; </span><br><span class="line">		a = a * a % c;</span><br><span class="line">		b &gt;&gt;= 1;                     //位运算：b /= 2; </span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两个易错点"><a href="#两个易错点" class="headerlink" title="两个易错点"></a>两个易错点</h1><h2 id="求最大值时先取模"><a href="#求最大值时先取模" class="headerlink" title="求最大值时先取模"></a>求最大值时先取模</h2><p>取mod的时候，如果题目要求你算最大值，并且说由于答案可能很大，输出结果请对1e9+7取，那你千万不能在max函数更新最大值时就取模，这样很可能会出错！</p>
<p>比如：题目过程中有四个数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2e9+7，1e9+6，1e9+5，1e9+4</span><br></pre></td></tr></table></figure>
<p>然后算法中你用max求最大值时，如果先模上1e9+7，那你会得到1e9，1e9+6，1e9+5，1e9+4，并且max函数算出的最大值是1e9+6，可是这四个数的最大值应该是2e9 + 7才对。</p>
<p>正确做法：在求max的时候不要先取mod，而是都以long long型数据比大小，最后得到最大值是2e9 + 7，再对它取mod，得到结果是1e9 + 7。</p>
<h2 id="直到return才取模"><a href="#直到return才取模" class="headerlink" title="直到return才取模"></a>直到return才取模</h2><p>如果让你算1+2+…+n的值（由于答案可能很大，输出结果请对1e9+7取）<br>n的取值范围是1 ~ 10^10000。</p>
<p>那显然如果在中间过程中不先取mod，必然会爆数据范围，因为不管是int还是long long甚至是double(最大10^308)都无法存下这个数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//	...</span><br><span class="line">long long res = 0;</span><br><span class="line"><span class="keyword">for</span>(int i = 1; i &lt;= n ; i++) </span><br><span class="line">    res = res + i; // n巨大，res无法存下这个数据</span><br><span class="line"><span class="built_in">return</span> res % (1e9 + 7);</span><br><span class="line">//	...</span><br></pre></td></tr></table></figure>

<p>正确的做法应该是计算的过程中取模：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//	...</span><br><span class="line">long long res = 0;</span><br><span class="line"><span class="keyword">for</span>(int i = 1; i &lt;= n ; i++) </span><br><span class="line">    res = (res + i) % (1000000007); // 计算的过程中取模</span><br><span class="line"><span class="built_in">return</span> res;</span><br><span class="line">//	...</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果回想上面，做幂运算的时候就是这样的过程，也是在运算的过程中进行取余的。总结起来就是在做题的开始就需要想好，到底是先取余还是计算以后取余。</p>
]]></content>
      <categories>
        <category>The C/CPP language</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>大数取余</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>老毛子路由器解锁网易云音乐</title>
    <url>/2020/27.UnblockCloudmusic/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>怎么说呢，网易云音乐是我一直在用的音乐app，黑色的主题我是真的很喜欢的呀，个人觉得非常好看，但是最近这两年来网易云音乐悦来月拉垮了，版权和直播那一块，让这个已经变得不想一个音乐app了。疫情在家的时候完了一下路由器，然后在大佬编译的OpenWrt的版本中有解锁网易云音乐的选项，然后我就开始了一系列的收集工作。</p>
<p>下面仅仅是我个人的小记录，如果不是很懂或者零基础的话请看<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1234066&highlight=%CD%F8%D2%D7%D4%C6%BD%E2%CB%F8" target="_blank" rel="noopener">52PJ</a>。</p>
<h1 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h1><p>硬件是联想的NeWifi3，这个路由器怎么说呢，也算是矿渣之一吧，不过全千兆和512m的内存，足够运行很多东西，刷了老毛子挂一个网站然后用花生壳直接映射到外网可以说是绰绰有余，但是我个人觉得不太稳定，于是打算做简单的小Nas使用，反正也不算啥，够用就行。</p>
<p>下面开始说正题，使用脚本来解锁网易云。先放大佬的<a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">github链接</a>，下载下来直接解压即可，然后使用FTP复制到路由器，然后开始配置环境就行了。</p>
<h1 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h1><p>上面的脚本就是使用Node来运行的，但是老毛子一般的话可能没有编译进去，于是便要自行安装，打开SSH链接路由器，一次输入下列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">unset</span> LD_LIBRARY_PATH</span><br><span class="line"><span class="built_in">unset</span> LD_PRELOAD</span><br><span class="line">mount -t tmpfs tmpfs /opt -o size=60M</span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> bin etc lib/opkg tmp var/lock</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">[ ! -d <span class="string">"/opt/<span class="variable">$folder</span>"</span> ] &amp;&amp; mkdir -p /opt/<span class="variable">$folder</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>下面安装OPkg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://pkg.entware.net/binaries/mipsel/installer/opkg -O /opt/bin/opkg</span><br><span class="line">wget http://bin.entware.net/mipselsf-k3.4/installer/opkg.conf -O /opt/etc/opkg.conf | chmod 755 /opt/bin/opkg</span><br></pre></td></tr></table></figure>

<p>update并且安装node</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/bin/opkg update</span><br><span class="line">/opt/bin/opkg install node</span><br></pre></td></tr></table></figure>

<p>此时可以使用下列指令查看node版本，并且确认node已经安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<h1 id="开始运行脚本"><a href="#开始运行脚本" class="headerlink" title="开始运行脚本"></a>开始运行脚本</h1><p>首先获取网易云音乐的ip，使用ping即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping music.163.com</span><br></pre></td></tr></table></figure>

<p>会返回相应的ip和延迟等数据，记住那个ip，然后在SSH中找到相应的脚本文件，可以看看我下图的。<br><img src="/images/RaspberryPi/3.1.png" alt="P3.1"><br>然后使用上面记录的ip，运行node即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node /home/root/UNM/app.js -p 8888 -f 59.111.181.60</span><br></pre></td></tr></table></figure>

<h1 id="设置APP代理"><a href="#设置APP代理" class="headerlink" title="设置APP代理"></a>设置APP代理</h1><p>打开网易云音乐后台的设置，找到工具中的代理选项，使用自定义代理，如下所示：<br><img src="/images/RaspberryPi/3.2.png" alt="P3.2"></p>
<h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1><p>完结撒花，感觉有这个脚本的花还是很好用的，关键是比如周杰伦的新歌都是有资源的，感觉很不错。</p>
]]></content>
      <categories>
        <category>解锁网易云音乐</category>
      </categories>
      <tags>
        <tag>老毛子</tag>
        <tag>解锁网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>小小总结一下C/C++的进制转换</title>
    <url>/2020/26.Hexadecimal-conversion/</url>
    <content><![CDATA[<h1 id="首先说要求"><a href="#首先说要求" class="headerlink" title="首先说要求"></a>首先说要求</h1><p>题目要求输入一个字符串，只有数字和大写字母，然后需要转换成十进制的没，需要判定的是基数和偶数，然后默认的进制需要自己设计，ok下面开始简答分析。</p>
<h1 id="进制转换的说明"><a href="#进制转换的说明" class="headerlink" title="进制转换的说明"></a>进制转换的说明</h1><p>其实进制转换也就是乘以基数的多少次方，然后相加即可。下面直接上代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int StrtoBool(string &amp;str, int r)</span><br><span class="line">&#123;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	//	进制转换</span><br><span class="line">	<span class="keyword">for</span>(int i = 0; i != str.size(); i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans *= r;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">			ans += str[i] - <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &gt;= <span class="string">'A'</span> &amp;&amp; str[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">			ans += str[i] - <span class="string">'A'</span> + 10;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">return</span> ans % 2;	//结果是只看奇数和偶数的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十进制转换为任意进制"><a href="#十进制转换为任意进制" class="headerlink" title="十进制转换为任意进制"></a>十进制转换为任意进制</h1><p>一般算法是除以基数，然后倒着取数，显然是栈的结构，先入后出。下面直给出完整版的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 0, r &#x3D; 10;	</span><br><span class="line">	stack&lt;char&gt; s;	&#x2F;&#x2F;全部存大写字母</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; r;	&#x2F;&#x2F;数字和进制（都是int类型的）</span><br><span class="line"></span><br><span class="line">	while(n)</span><br><span class="line">	&#123;</span><br><span class="line">		char tmp ;</span><br><span class="line">		tmp &#x3D; n%r;</span><br><span class="line">	</span><br><span class="line">		if(tmp &gt;&#x3D; 0 &amp;&amp; tmp &lt;&#x3D; 9)</span><br><span class="line">			tmp +&#x3D; 48;		&#x2F;&#x2F;	得到字符的0-9</span><br><span class="line">		else </span><br><span class="line">			tmp +&#x3D; 55;		&#x2F;&#x2F;	得到大写的数字（暂时没有处理Z以后的）</span><br><span class="line">		s.push(tmp);</span><br><span class="line">		n &#x2F;&#x3D; r;</span><br><span class="line">	&#125;</span><br><span class="line">	for(;!s.empty();)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>The C/CPP language</category>
      </categories>
      <tags>
        <tag>The C/CPP language</tag>
        <tag>Hexadecimal Conversion</tag>
      </tags>
  </entry>
  <entry>
    <title>使用循环链表解决约瑟夫问题(Josephus Problem)</title>
    <url>/2020/25.C-Josephus-Problem/</url>
    <content><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>约瑟夫问题是个有名的问题:N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。<br>同理还有丢手绢，猴子称王都是一模一样的问题，首先用循环就可以直接一次性解决，记录当前位置的数并且循环取余即可，但是直观而言，肯定是循环数组更加的直观！</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>不哆嗦了，直接贴上，里面注释还是很多的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">//定义循环链表</span><br><span class="line">typedef struct node//定义node结构体</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125;cLinkList;//typedef struct node* cLinkList;定义一个struct node类型的循环链表</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cLinkList *head, *p, *s, *temp;</span><br><span class="line">    int n, k;</span><br><span class="line">    int i = 1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter the total number n:\n"</span>);</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter the key value:\n"</span>);</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    k %= n;</span><br><span class="line">    head = (cLinkList *)malloc(sizeof(cLinkList));</span><br><span class="line">    p = head;</span><br><span class="line">    p-&gt;next = p;//这里要赋值为p，不能赋值为head，要保持head的位置不变</span><br><span class="line">    p-&gt;data = i;</span><br><span class="line">    <span class="keyword">for</span>(i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (cLinkList *)malloc(sizeof(cLinkList));</span><br><span class="line">        s-&gt;data = i;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    int total = n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = 1; i &lt; k - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>, p-&gt;next-&gt;data);</span><br><span class="line">        temp = p-&gt;next;//temp为要删除的元素</span><br><span class="line">        p-&gt;next = temp-&gt;next;//链表中跳过temp</span><br><span class="line">        free(temp);//释放temp</span><br><span class="line">        p = p-&gt;next;//p向前移动继续寻找</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Done！\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>The C/CPP language</category>
      </categories>
      <tags>
        <tag>The C/CPP language</tag>
        <tag>Josephus Problem</tag>
      </tags>
  </entry>
  <entry>
    <title>空指针、野指针与悬垂指针</title>
    <url>/2020/24.C-point/</url>
    <content><![CDATA[<h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p>空指针：指针指向的地址为空的指针叫空指针/NULL指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int *p1;</span><br><span class="line">p1 = NULL;</span><br><span class="line"></span><br><span class="line">char *p2;</span><br><span class="line">p2 = NULL;</span><br></pre></td></tr></table></figure>

<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称悬垂指针（也叫迷途指针）。<br>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int *p1;		//这里p1没有初始化的赋值，随机只想一个地址，是野指针</span><br><span class="line">p1 = &amp;a;		//指向了值</span><br><span class="line"></span><br><span class="line">// 指针在申请的时候一定要赋值，至少要给NULL！</span><br><span class="line">char *p2 = NULL;</span><br></pre></td></tr></table></figure>

<h1 id="悬垂指针"><a href="#悬垂指针" class="headerlink" title="悬垂指针"></a>悬垂指针</h1><p>悬垂指针：指针所指向的对象已经被释放或者回收了，但是指向该对象的指针没有作任何的修改，仍旧指向已经回收的内存地址。 此类指针称为垂悬指针。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   char *dp = NULL;</span><br><span class="line">   &#123;</span><br><span class="line">       char c;</span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   &#125; /* c falls out of scope */</span><br><span class="line">     /* dp is now a dangling pointer */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个很常见的失误是返回一个栈分配的局部变量：一旦调用的函数返回了，分配给这些变量的空间被回收，此时它们拥有的是“垃圾值”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int *func(void)</span><br><span class="line">&#123;</span><br><span class="line">    int num = 1234;</span><br><span class="line">    /* ... */</span><br><span class="line">    <span class="built_in">return</span> &amp;num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 func 后，尝试从该指针暂时能读取到正确的值（1234），但是再次调用函数后将会重写栈为 num 分配的的值，再从该指针读取的值就不正确了。如果必须要返回一个指向 num 的指针，num 的作用域必须大于这个函数——它也许被声明为 static。</p>
<h1 id="避免悬垂指针错误"><a href="#避免悬垂指针错误" class="headerlink" title="避免悬垂指针错误"></a>避免悬垂指针错误</h1><p>在 C/C++ 中，一种最简单的技术是实现一个 free()（或类似的）替代版本或者 delete 析构器来保证指针的重置。然后，这个技术不会清除其他指针变量，它们含有该指针的副本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Alternative version <span class="keyword">for</span> <span class="string">'free()'</span> */</span><br><span class="line">void safefree(void **pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp != NULL) &#123;               /* safety check */</span><br><span class="line">        free(*pp);                  /* deallocate chunk, note that free(NULL) is valid */</span><br><span class="line">        *pp = NULL;                 /* reset original pointer */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int f(int i)</span><br><span class="line">&#123;</span><br><span class="line">    char *p = NULL, *p2;</span><br><span class="line">    p = (char *)malloc(1000);    /* get a chunk */</span><br><span class="line">    p2 = p;              /* copy the pointer */</span><br><span class="line">    /* use the chunk here */</span><br><span class="line">    safefree(&amp;p);       /* safety freeing; does not affect p2 variable */</span><br><span class="line">    safefree(&amp;p);       /* this second call won<span class="string">'t fail */</span></span><br><span class="line"><span class="string">    char c = *p2;       /* p2 is still a dangling pointer, so this is undefined behavior. */</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>The C/CPP language</category>
      </categories>
      <tags>
        <tag>CRC Check</tag>
        <tag>The C/CPP language</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔试中的获取数据问题</title>
    <url>/2020/23.GetData-C/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近做字节笔试的时候经常会出现一些数据解析的问题，比如输入”(1,2)”这种数据，要求提取其中的坐标，还有就是输入一长串数据，如”1 2 3 4 5”说是遗传数据，没有指定长度，前面一直死在数据的获取上面，可能半个小时都没有获取到数据，后面机制知道怎么做也不可能有通过率。后面进行了了一些小总结，有了后面的结果，也想做一个小小的开源分享吧。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>仔细分析上面的内容，发现两个点，一个使输入的长度不固定，而且数组的多少也不固定，因此没有办法用固定的方法去解析。</p>
<p>看了一下C++的常用数据类型，发现容器使可以很方便实现变长的类似数组功能，然后就是输入的数据，这个好办，直接输入字符串解析就好了，下面开写，具体代码如下。首先是main.c:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include "GetData.h"</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	// cout &lt;&lt; isNumber(<span class="string">'.'</span>) &lt;&lt;endl;</span><br><span class="line">	// GetData_Print();</span><br><span class="line"></span><br><span class="line">	string str;</span><br><span class="line">	getline(cin, str);</span><br><span class="line">	GetData(str);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是GetData.cpp:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include "GetData.h"</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetData_Print(void)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"GetData test!"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isNumber(char tmp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> ( (tmp &gt;= <span class="string">'0'</span>) &amp;&amp; (tmp &lt;= <span class="string">'9'</span>) ) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从一行字符串获取相应的数据，解析到动态的容器中</span><br><span class="line">int GetData(string str)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0, data = 0;</span><br><span class="line">	bool update = <span class="literal">false</span>;	//是否存储数据</span><br><span class="line">	int  symbol = 1	   ;	//正负号的判定(+1或者-1)</span><br><span class="line">	vector &lt;int&gt; array1;	//存储不定长的数据</span><br><span class="line">	<span class="keyword">for</span>(int i = 0; i &lt; str.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] == <span class="string">'-'</span> &amp;&amp; isNumber(str[i+1]))</span><br><span class="line">			symbol = -1;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">				data = 10*data + (str[i] - <span class="string">'0'</span>), update = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(update)</span><br><span class="line">				array1.push_back(symbol*data), data = 0, update = <span class="literal">false</span>, symbol = 1;</span><br><span class="line">			<span class="keyword">if</span>(update&amp;&amp;i == str.size() - 1)//需对字符串最后的数字进行判断</span><br><span class="line">				array1.push_back(symbol*data), symbol = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Result:"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(int j = 0; j &lt; array1.size(); j++)</span><br><span class="line">		cout &lt;&lt; array1[j] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是GetData.h</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifndef GETDATA_H</span></span><br><span class="line"><span class="comment">#define GETDATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetData_Print(void);</span><br><span class="line">bool isNumber(char tmp);</span><br><span class="line">int GetData(string str);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>上面的已经是改的第二版了，已经完美支持负数的解析了，而且个人比较喜欢代码行数比较少，因此if里面很多的幅值部分就直接用都好隔开了，我知道不是一个好习惯，但是我个人看着的确好看写，勿喷勿喷。测是结果如下：<img src="/images/C-Language/2-2.png" alt="2.2"></p>
<p>可以看到已经解析了数据，但是其中有一个小问题，就是实际操作中判断符号哪里我用到了[i+1],如果测试代码中只有一个字符是会溢出的，但是笔试的用例好像没有这个情况，因为他们都是给的指定的输入，对这个还是比较放心的，只是做一个简单的分享吧。</p>
]]></content>
      <categories>
        <category>The C/C++ language</category>
      </categories>
      <tags>
        <tag>The C/C++ language</tag>
        <tag>Getdata</tag>
      </tags>
  </entry>
  <entry>
    <title>关于相机的一些记录</title>
    <url>/2020/22.Camera/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近花了巨资买了一个相机（现在还有点心疼），型号是索尼的A7m2，刚刚上手还不习惯只能用自动模式，不过我肯定是不想妥协的，所以想写这个博客来记录一些摄影学习之路，所以这个可能是会长期更新的。（其实我是经常忘记内容所以来记录一下2333）</p>
<h1 id="关于照相模式"><a href="#关于照相模式" class="headerlink" title="关于照相模式"></a>关于照相模式</h1><p>索尼的A7m2照相模式是通过旋转顶部的旋钮来的，具体如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>程序自动（自动设置光圈和快门速度，可根据需要设定其他设置）</td>
</tr>
<tr>
<td>A</td>
<td>光圈优先（调节光前以改变对角范围和背景模糊程度，小值：前后模糊，大值：背景对焦）</td>
</tr>
<tr>
<td>S</td>
<td>快门优先（手动调节快门速度已实现移动被摄体的不同效果）</td>
</tr>
<tr>
<td>M</td>
<td>手动曝光（手动调节光圈和快门速度）</td>
</tr>
<tr>
<td>[_]</td>
<td>扫描全景（以固定速度上下左右移动小计）</td>
</tr>
<tr>
<td>SCN</td>
<td>场景选择（选择适合索要拍摄物体和环境的模式）</td>
</tr>
<tr>
<td>AUTO</td>
<td>自动设置（系统根据环境自动设置选项，包括降低模糊和噪点）</td>
</tr>
</tbody></table>
<h1 id="关于人像LR的设置"><a href="#关于人像LR的设置" class="headerlink" title="关于人像LR的设置"></a>关于人像LR的设置</h1><p>目前拍了一些照片了，对修图也有一定的认识吧，下面说说修人像我自己常用到的一些方法。提前声明：我的LR版本是2020的，版本比较新，功能也比较多。</p>
<p>首先是曝光，啥都不管，直接拉曝光，一般而言会显得很白，然后皮肤也会显得比较好看，这个是必调的！</p>
<p>第二是偏好设置中的“纹理”和“清晰度”这两个选项，这两个我会拉到-20左右的值，因为这样会有一个朦胧感和相对的清晰感。纹理拉高了锐化非常严重，清晰度拉高了太亮，也有锐化的那种感觉，显得生硬，对于妹子而言肯定是不合适的，因此我都拉到负值，我觉得-20左右是一个挺不错的数值。</p>
<p>第三是鲜艳度和饱和度，这个的话看整体颜色怎么样，这两个选项适当微调，饱和度一般我给一个-5左右就行。</p>
<p>第四是曲线，这个也是PS调整的精髓之一了，在新手过程中，我只用万能的S型曲线，即高光向上拉，阴影向下即可，这个一直盯着画面，怎么好看怎么来。</p>
<p>第五也是我觉得最好用的选项之一，就是“细节”这个选项中的“噪点消除”，在明亮度我一般选择25-30这样的数值，噪点消除这个功能不仅仅是消除噪点，我个人感觉它使用了均值的算法来消除的，对于妹子的皮肤而言，有一个很好的磨皮效果，真的非常赞！！！</p>
<p>其次还有的细节就是在“HSL/颜色”这个选项中的内容，里面有色相，饱和度，明亮度和全部的选项，这些内容都是需要根据内容微调的。里面的色相中的黄色和绿色可以稍微尝试一下，对于肤色而言可以有较大的改善，还有饱和度中的红色，拉高可以调节口红的颜色深度，如果周围的红色影响不大的话。</p>
<p>以后有好的经验总结也会多写写的~</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>目前打算可能会一直更新，暂时没有结语~</p>
]]></content>
      <categories>
        <category>Camera</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装和简单使用CMake</title>
    <url>/2020/21.Ubuntu-CMake/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近想简单学习一下CMake，因为比较好用，而且也会偏向多平台，为了方便的话我也是直接就在Ubuntu和Win10都进行了安装，现在介绍的是Ubuntu平台上面的，Win平台上面也是大同小异，而且教程也挺多的，不必纠结。</p>
<h1 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h1><h2 id="直接命令行"><a href="#直接命令行" class="headerlink" title="直接命令行"></a>直接命令行</h2><p>我当时就感觉CMake比较流行，直接尝试了指令，发现真的可以，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure>

<h2 id="官网下载安装"><a href="#官网下载安装" class="headerlink" title="官网下载安装"></a>官网下载安装</h2><p>这个里面也有两种方法，优点也比较明确。首先是可以选择版本，其次是可以下载源码自己编译，尤其是自己交叉编译Android平台的opencv时会提示版本过低。安装版本的和用指令的一样，下面简单介绍下载源码编译的。</p>
<p>到<a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake官网</a>下载最新的cmake。下载后解压,然后进入目录执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bootstrap</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>然后验证版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>如果实用安卓的opencv的话还需要将Android Sdk中的cmake软链接到/usr/local/bin目录中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/gavinandre/Android/Sdk/cmake/3.6.4111459/bin/cmake /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>

<h1 id="CMake示例"><a href="#CMake示例" class="headerlink" title="CMake示例"></a>CMake示例</h1><p>首先编写一个简单的cpp文件，取名 main.cpp, 写一个简单的hello world程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写CMakeLists.txt文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"><span class="comment">#工程名</span></span><br><span class="line">project(HELLOWORLD)</span><br><span class="line"><span class="comment">#包含原程序,即把给定目录下的源程序复制给变量DIR_SRC</span></span><br><span class="line"><span class="comment">#将指定路径下的源文件储存在指定的变量中</span></span><br><span class="line">aux_source_directory(./ DIR_SRC)</span><br><span class="line"><span class="comment">#生成程序</span></span><br><span class="line">add_executable(helloworld <span class="variable">$&#123;DIR_SRC&#125;</span>)</span><br></pre></td></tr></table></figure>


<p>最后编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> build</span><br><span class="line"><span class="variable">$cd</span> build</span><br><span class="line"><span class="variable">$cmake</span> ..</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line">$./helloworld</span><br></pre></td></tr></table></figure>

<p>可以看到编译结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>可以看到在linux下面安装和使用Cmake还是比较方便的，目前而言我对Cmake的语法也不是很熟悉，但是仍然感觉还是觉得挺好用的。</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题与递归的思路总结</title>
    <url>/2020/20.Recursion%20problem/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>递归问题一直是笔试的重点，下面开始简单总结递归的问题，主要是递归思考的思路，还有就是怎么用编程的方式来实现。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>经典的汉诺塔问题就是最好的递归例子，早期相信很多的手机上面也有这个小游戏吧，就是移动圈圈的问题。以三个圈圈移动为例<img src="/images/C-Language/hannuo.gif" alt="P1.1"></p>
<p>递归主要的思路就是找到 n 和 n-1 步的规律，还有就是递归停止的条件。在这个汉诺塔中，显然，n=1就直接移动过去了，主要是关于数量较多的时候的规律。</p>
<p>首先是移动的函数move，写函数的主要思路是A通过B移动到C，这个一定要理解出来:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void move(int n, char c1, char c2, char c3)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == 1)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %c -&gt; %c \n"</span>, c1, c3);</span><br><span class="line">    //  暂时没写完，后面还有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是分析规律，汉诺塔的方式其实还比较简简单，就是先将 n-1 行移动到 B，然后将第 n 行移动到 C，最后将 B 上面的 n-1 行移动到 C 即可。具体如下（很抱歉公式编辑器出来的式子好像有点麻烦在这里显示不出来就用图片来代替了）：<br> <img src="/images/C-Language/2.1.png" width = "200" height = "110" alt="图片名称" align=center /></p>
<p> 如实就可以写完整的函数了，如下：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void move(int n, char c1, char c2, char c3)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == 1)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %c -&gt; %c \n"</span>, c1, c3);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		move(n-1, c1, c3, c2);</span><br><span class="line">		move(1, c1, c2, c3);</span><br><span class="line">		move(n-1, c2, c1, c3);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际使用中只需要调用move函数即可，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	move(5,<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>递归问题其实是一个常用的思路，但是由于其资源的耗费很多，而且堆栈资源的实用巨大，导致在牛客或者力上面扣做题实用递归常常会可能时间太长了。</p>
<p>结论：在实际使用中如果能用循环解决一定不要用递归！</p>
]]></content>
      <categories>
        <category>The C++ language</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Hanota</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装Samba</title>
    <url>/2020/19.Ubuntu-Samba/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Samba在linux的应用应该来说还是非常广泛的，不管是商业用的NAS，还是自己手头分享用的文件共享，Samba由于其良好的共享性能都广受好评，但是新手常常在Ubuntu上面配置的时候经常出现一些小问题，如是广泛阅读了很多资料，最后发现还是<a href="https://ubuntu.com/tutorials/install-and-configure-samba#1-overview" target="_blank" rel="noopener">官网</a>可靠，下面做一个简单的记录，分享Ubuntu上面Samba的使用(16.04-20.04均可用)。</p>
<h1 id="首先安装Samba"><a href="#首先安装Samba" class="headerlink" title="首先安装Samba"></a>首先安装Samba</h1><p>为了安装Samba，我们运行下列指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure>

<p>为了确保安装成功，我们需要进行简单的确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis samba</span><br></pre></td></tr></table></figure>

<p>下面是返回的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">samba: /usr/sbin/samba /usr/lib/samba /etc/samba /usr/share/samba /usr/share/man/man7/samba.7.gz /usr/share/man/man8/samba.8.gz</span><br></pre></td></tr></table></figure>

<h1 id="其次是配置Samba"><a href="#其次是配置Samba" class="headerlink" title="其次是配置Samba"></a>其次是配置Samba</h1><p>目前来说Samba已经安装好了，下面开始新建一个共享的文件夹，这里建议最好就用/home里面自己这个用户的文件夹(下面的“username”记得换成自己的用户名)，这样可以避免一些权限的问题，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/&lt;username&gt;/sambashare/</span><br></pre></td></tr></table></figure>

<p>然后就能添加用户信息啦，运行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>

<p>添加下面的内容到smb.conf文件中，记住下面的“username”还是要换成自己的用户名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[sambashare]</span><br><span class="line">    comment = Samba on Ubuntu</span><br><span class="line">    path = /home/username/sambashare</span><br><span class="line">    <span class="built_in">read</span> only = no</span><br><span class="line">    browsable = yes</span><br></pre></td></tr></table></figure>
<p>这里如果对VIM或者nano不熟悉的话也可以用图形化界面的gedit来编辑，简单安装就行，也是非常方便，上面的指令看起来也是非常的简单易懂。</p>
<p>最后我们开始设置Samba服务，首先是开启这个服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure>
<p>更新防火墙规则来允许Samba通讯：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow samba</span><br></pre></td></tr></table></figure>

<p>结尾的一部就是添加用户啦，指令如下(这里的“username”还是要换成自己的用户名，不然不允许共享)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a username</span><br></pre></td></tr></table></figure>

<h1 id="其他设备连接"><a href="#其他设备连接" class="headerlink" title="其他设备连接"></a>其他设备连接</h1><p>一般不同的设备之间可能会有一些不同，但是都大同小异。常用的一般是Win10和MacOS，一般需要获取局域网内需要共享的机器的局域网IP，比如自己的IP是:192.168.175.129，具体如下：</p>
<p>Win10在文件资源管理器直接输入下列指令，输入账号和密码即可访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\\ip-address\sambashare</span><br></pre></td></tr></table></figure>

<p>MaxOs输入的指令略微不同，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smb://ip-address/sambashare</span><br></pre></td></tr></table></figure>
<p>这样Samba的配置就全部完成了，非常使实用！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>还是看<a href="https://ubuntu.com/tutorials/install-and-configure-samba#1-overview" target="_blank" rel="noopener">官方文档</a>最靠谱！！！</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Samba</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的一些基础知识</title>
    <url>/2020/18.Basics%20of%20C/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近准备在投简历，也是总结总结一下C语言的基础知识，做一些准备。首先说明，下文后面所做的所有的实验都是在win10_1909_x64环境下，gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)，软件使用的是VSCode。在C语言多线程的使用中，在VSCode配置好了C语言的基本环境之后就能直接使用了。</p>
<h1 id="C语言的字与字节"><a href="#C语言的字与字节" class="headerlink" title="C语言的字与字节"></a>C语言的字与字节</h1><p>变量大家肯定都熟悉，我的理解是一块内存存储的可变内容。一般来说，多个数据在内存中是连续存储的，彼此之间没有明显的界限，如果不明确指明数据的长度，计算机就不知道何时存取结束。下面对基础的内容进行说明。</p>
<p>首先是<strong>位</strong>（Bit）：表示二进制数码，只有0和1，是计算机处理和保存信息的最基本的单位。</p>
<p>其次是<strong>字节</strong>（Byte）：一个字节由8个位组成，他是作为一个完整单位的8个二进制数码，最开始学习的C语言内容之一就是ASCII编码/《美国国家信息交换标准代码》，下面的图展示了AscII编码的一些信息，里面我觉得印象深刻的圈出来了。</p>
<p>最后是<strong>字</strong>（Word）：一个字由两个字节组成，它表示计算机处理指令或者数据的二进制位数。通常称16位是一个字，32位是一个双字，64位是两个双字。<br><img src="/images/C-Language/1.1.png" alt="P1.1"></p>
<h1 id="C语言的变量长度"><a href="#C语言的变量长度" class="headerlink" title="C语言的变量长度"></a>C语言的变量长度</h1><p>变量的长度，准确来说应该是便来那个类型所占的字节数，也做一个小小的总结吧，具体内容如下所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>char[1]</td>
<td>1</td>
</tr>
<tr>
<td>char[2]</td>
<td>2</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>short[1]</td>
<td>2</td>
</tr>
<tr>
<td>short[2]</td>
<td>4</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>int[1]</td>
<td>4</td>
</tr>
<tr>
<td>int[2]</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>float[1]</td>
<td>4</td>
</tr>
<tr>
<td>float[2]</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>double[1]</td>
<td>8</td>
</tr>
<tr>
<td>double[2]</td>
<td>16</td>
</tr>
</tbody></table>
<p>尤其注意的是C语言中的bool变量，在C98是标准中是没有定义bool类型变量的，直接引用会报错，一般可以用define或者枚举型便来那个来表示，还有一种方法是在头文件中添加”stdbool.h”这个头文件来引用即可，下面是具体的一些代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "stdbool.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(int));       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(int[1]));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(int[2]));    </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(char));      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(char[1]));   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(char[2]));   </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(double));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(double[1])); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(double[2])); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(<span class="built_in">float</span>));     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(<span class="built_in">float</span>[1]));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(<span class="built_in">float</span>[2]));  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(short));     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(short[1]));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(short[2]));  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(bool));      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(bool[1]));   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(bool[2]));   </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sizeof(long));      </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据结构的字节对齐"><a href="#数据结构的字节对齐" class="headerlink" title="数据结构的字节对齐"></a>数据结构的字节对齐</h1><p>这个是一个非常重要的知识点，面试经常考，具体是个什么意思呢，跑一下下面的代码就知道了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "stdbool.h"</span></span><br><span class="line"></span><br><span class="line">struct t1</span><br><span class="line">&#123;</span><br><span class="line">    char a1;</span><br><span class="line">    char b1;</span><br><span class="line">    char c1;</span><br><span class="line">    int  d1;</span><br><span class="line">    char e1;</span><br><span class="line">&#125;T1;</span><br><span class="line"></span><br><span class="line">struct t2</span><br><span class="line">&#123;</span><br><span class="line">    char a2;</span><br><span class="line">    char b2;</span><br><span class="line">    char c2;</span><br><span class="line">    char e2;</span><br><span class="line">    int  d2;</span><br><span class="line">&#125;T2;</span><br><span class="line"></span><br><span class="line">struct t3</span><br><span class="line">&#123;</span><br><span class="line">	double a2;</span><br><span class="line">	char b2;</span><br><span class="line">	int  c3;</span><br><span class="line">&#125;T3;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>, sizeof(T1), sizeof(T2), sizeof(T3));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的输出分别是 “12 8 16”，两个基本相同的两个结构体长度是不一样，这个就是字节对齐。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<p>揭示了原因，现在上面的例子应该就比较好分析了，<strong>windows 64 位默认 结构体对齐系数为8，32位 结构体对齐系数为4，而且在VC/C++和GNU GCC中都是默认是4字节对齐</strong>。<br>T1结构体分三段：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>1+1+1</td>
<td>4  [对齐4]</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>4  [对齐4]</td>
</tr>
</tbody></table>
<p>T2结构体分两段：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>1+1+1+1</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<p>T3结构体分两段：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1+4</td>
<td>8</td>
</tr>
</tbody></table>
<p>现在对字节对齐已经有了一个比较深刻的认识了大，他是由于计算机在高速读取的时候为了保证读取效率而设计的，但是我们在做嵌入式开发钟数据处理和传输数据的时候，经常设计一些自定义的通信协议，如果按照这种设计反而会降低通信效率，而且如果接收方不清楚这些内容可能会引起一些问题，因此也有一定的方法来取消字节对齐或者自行设计对齐的长度。</p>
<p>　　· 使用伪指令#pragma pack (n)，编译器将按照n个字节对齐；<br>　　· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。　</p>
<p>注意：如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。</p>
<p>另一种方式比较简单，直接在结构体后面加上<code>__attribute__((packed))</code>，这个是直接取消字节对齐的，或者用<code>__attribute__((aligned(n)))</code>，这个跟<code>pragma pack (n)</code>效果相同。</p>
<p>可以尝试下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "stdio.h"</span></span><br><span class="line"><span class="comment">#include "stdbool.h"</span></span><br><span class="line"></span><br><span class="line">struct t1</span><br><span class="line">&#123;</span><br><span class="line">    char a1;</span><br><span class="line">    char b1;</span><br><span class="line">    char c1;</span><br><span class="line">    int  d1;</span><br><span class="line">    char e1;</span><br><span class="line">&#125;__attribute__((packed)) T1;</span><br><span class="line"></span><br><span class="line">struct t2</span><br><span class="line">&#123;</span><br><span class="line">    char a2;</span><br><span class="line">    char b2;</span><br><span class="line">    char c2;</span><br><span class="line">    char e2;</span><br><span class="line">    int  d2;</span><br><span class="line">&#125;__attribute__((aligned(2))) T2;</span><br><span class="line"></span><br><span class="line">struct t3</span><br><span class="line">&#123;</span><br><span class="line">	double a2;</span><br><span class="line">	char b2;</span><br><span class="line">	int  c3;</span><br><span class="line">	int  d3;</span><br><span class="line">&#125;__attribute__((aligned(4))) T3;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>, sizeof(T1), sizeof(T2), sizeof(T3));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为”8 8 24”，有兴趣可以自己对比前面的内容并且简单计算一下。</p>
]]></content>
      <categories>
        <category>The C language</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>Some basics</tag>
        <tag>变量长度</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现CRC检验</title>
    <url>/2020/17.C-CRC/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>之前在做一个项目的时候，为了保证数据的准确性，用到了CRC检验，现在将其总结一下，顺便也复习一下。首先说一下CRC校验，他的全称是循环冗余校验（cyclic redundancy check）。CRC检验的基本思想是利用线性编码理论，在发送端根据要传送的k位二进制码序列，以一定的规则产生一个检验码r位(就是CRC码)，附在信息后面，构成一个新的二进制码序列数共(k+r)位，最后发送出去。接收端根据同样的规则校验，以确定传送中是否出错。接收端有两种处理方式：1、计算k位序列的CRC码，与接收到的CRC比较，一致则接收正确。2、计算整个k+r位的CRC码，若为0，则接收正确。CRC码有多种检验位数，8位、16位、32位等，原理相同。16位的CRC码产生的规则是先将要发送的二进制序列数左移16位（即乘以2的16次方后），除以一个多项式，最后所得到的余数就是CRC码。</p>
<p>不说复杂了，CRC 算法的基本思想是将传输的数据当做一个位数很长的数，将这个数除以另一个数，得到的余数作为校验数据附加到原数据后面。除法采用正常的多项式乘除法，而加减法都采用模2运算。模2运算就是结果除以2后取余数，如 3 mod 2 = 1，在计算机中就是异或运算！下面举例说一下：</p>
<h1 id="CRC介绍"><a href="#CRC介绍" class="headerlink" title="CRC介绍"></a>CRC介绍</h1><h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>之前做项目的时候也参考了很多资料，目前根据根据回忆写这篇博客也是参考了很多别人的东西，例如：<a href="https://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="noopener">liyuanbhu</a>的CSDN频道，<a href="https://zhuanlan.zhihu.com/p/77408094" target="_blank" rel="noopener">mculover666</a>的知乎回答，还有<a href="https://www.jb51.net/article/36832.htm" target="_blank" rel="noopener">脚本51</a>的分析介绍。通过这些我也学习到了很多的东西，对CRC检验也有了深刻的体会，我觉得还是挺开心的！</p>
]]></content>
      <categories>
        <category>The C/C++ language</category>
      </categories>
      <tags>
        <tag>The C language</tag>
        <tag>CRC Check</tag>
      </tags>
  </entry>
  <entry>
    <title>在51和STM32单片机上分别实现任意串口的类似printf操作</title>
    <url>/2020/16.C-uprintf/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这个是在本科的时候就弄好了，最近整理本科的一些文件的时候又看到了这些，如是准备做一些小结，也是给自己回忆一下。在51和STM32两款单片机实现C语言自带的printf操作，打印在串口中断，或者用于串口的通讯，下面是具体的操作。</p>
<h1 id="关于串行和并行"><a href="#关于串行和并行" class="headerlink" title="关于串行和并行"></a>关于串行和并行</h1><p>在计算机和终端之间的数据传输通常是靠电缆或信道上的电流或电压变化实现的，通信电压或者电流的变化实现通信。如果一组数据的各数据位在多条线上同时被传输，这种传输方式称为并行通信。串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去。简单来说就是串行线材少，信息连续发送，并行信号同时发送，可以同时发送较多的信息，下面介绍单片机的串口通信。</p>
<p>串口通信(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。这种通信方式使用的数据线少，在通信中虽然传输速度比并行传输低，但是由于咸菜数量少，可以节约通信成本，而且在链接过程中非常方便，因此广泛使用。关于串口的相关知识点，比如：波特率， 数据为， 停止位， 奇偶检验位等等的具体信息王珊又很多的内容，这里就不具体介绍了，下面具体说明常用的两款单片机：51/STM32，他们是怎么配置的；</p>
<h1 id="51单片机操作"><a href="#51单片机操作" class="headerlink" title="51单片机操作"></a>51单片机操作</h1><p>首先是串口的初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//串口初始化</span><br><span class="line">void UartInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    SCON  = 0x50;		        // SCON: 模式 1, 8-bit UART, 使能接收  </span><br><span class="line">    TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重装</span><br><span class="line">    TH1   = 0xFD;               // TH1:  重装值 9600 波特率 晶振 11.0592MHz  </span><br><span class="line">    TR1   = 1;                  // TR1:  timer 1 打开                         </span><br><span class="line">    EA    = 1;                  //打开总中断</span><br><span class="line">//	ES    = 1;                  //打开串口中断</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//串口中断程序</span><br><span class="line">void UART_SER (void) interrupt 4 //串行中断服务程序</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char Temp;          //定义临时变量 </span><br><span class="line">	<span class="keyword">if</span>(RI)                       //判断是接收中断产生</span><br><span class="line">    &#123;</span><br><span class="line">		RI=0;                    //标志位清零</span><br><span class="line">		Temp = SBUF;             //读入缓冲区的值</span><br><span class="line">		SBUF = Temp;             //把接收到的值再发回电脑端</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(TI)                       //如果是发送标志位，清零</span><br><span class="line">	&#123;</span><br><span class="line">		TI=0;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是发送单个字节：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送一个字节</span><br><span class="line">void SendByte(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">	SBUF = dat;</span><br><span class="line">	<span class="keyword">while</span>(!TI);</span><br><span class="line">		TI = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做一个说明，如果使用默认的库中的printf函数是可以的，他向下调用了“char puchar(char c);”这个在”stdio.h”中的函数，因此只需要给“putchar(char c)”给重定向即可使用printf了，使用如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重定向</span><br><span class="line">char puchar(char c)</span><br><span class="line">&#123;</span><br><span class="line">    SendByte(c);</span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重定向之后就可以尽情使用printf了！但是也有一些列的缺点，因为printf函数在库中就会占用1k左右的代码量，因此在小容量的51单片机中还是谨慎使用，下面给出一个更好的方法，就是sprintf函数，他与printf非常像素，但是他将内容映射到一个字符串，然后在将字符串按照字符一个一个发送出去，因此字符串长度可控，占用空间更少，效率也更高！具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送字符串</span><br><span class="line">void SendStr(unsigned char *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(*s!=<span class="string">'\0'</span>)	// \0 表示字符串结束标志</span><br><span class="line">	&#123;</span><br><span class="line">		SendByte(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以发送任意的字符串了，下面操作的时候先用sprintf转化一下即可，比如我想发送一个可变长度的helloworld，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i = 8; i &lt; 12; i++&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    char Temp_S[15];</span><br><span class="line">    sprintf(Temp_S, <span class="string">"Hello World %d"</span>, i);</span><br><span class="line">    SendStr(Temp_S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于51单片机的说明就到这里，节约一点空间来讲，使用 sprintf + SendStr 这样的肯定是最好的。</p>
<h1 id="STM32单片机操作"><a href="#STM32单片机操作" class="headerlink" title="STM32单片机操作"></a>STM32单片机操作</h1><p>STM32的程序我是基于<a href="http://www.openedv.com/" target="_blank" rel="noopener">正点原子</a>的来改的，也去他的论学习了很多知识，关于串口的这个也是参考了这个里面很多。原子哥文件里面默认是支持printf的，但是默认是一个，因为printf也是需要一个重定向，在usart.c文件中有说明，重定向那个串口就能用那个串口使用printf函数，具体函数如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重定义fputc函数 </span><br><span class="line">int fputc(int ch, FILE *f)</span><br><span class="line">&#123;      </span><br><span class="line">	<span class="keyword">while</span>((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕   </span><br><span class="line">    USART1-&gt;DR = (u8) ch;      </span><br><span class="line">	<span class="built_in">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是但是但是，如果想使用多个串口通信而且想用printf这样方便的函数输出信息怎么办呢？当然有办法，那就是自定义一个，过程的话注释写的很清楚，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//用串口写一个<span class="built_in">printf</span>函数</span><br><span class="line">void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap; //typedef char *va_list; va_list是char型的指针</span><br><span class="line">    char *s_string = malloc(300); //申请缓冲区</span><br><span class="line">    va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap</span><br><span class="line">    vsprintf(s_string, fmt, ap); //类似sprintf函数</span><br><span class="line">    USART_String(USARTx, s_string); //发送和整个字符串</span><br><span class="line">    va_end(ap); //结束</span><br><span class="line">    free(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是完整的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "uart_x.h"</span></span><br><span class="line"><span class="comment">#include "stdlib.h"</span></span><br><span class="line"><span class="comment">#include "stdarg.h"</span></span><br><span class="line">//发送一个字节</span><br><span class="line">void SendByte(USART_TypeDef *USARTx, unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>((USARTx-&gt;SR &amp; 0X40) == 0) &#123;&#125;; //循环发送,直到发送完毕</span><br><span class="line">    USARTx-&gt;DR = (u8) dat;</span><br><span class="line">&#125;</span><br><span class="line">//发送一个字符串</span><br><span class="line">void USART_String(USART_TypeDef *USARTx, char *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">'\0'</span>)	// <span class="string">'\0'</span> 表示字符串结束标志</span><br><span class="line">    &#123;</span><br><span class="line">        SendByte(USARTx, *s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用串口写一个<span class="built_in">printf</span>函数</span><br><span class="line">void uprintf(USART_TypeDef *USARTx, const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap; //typedef char *va_list; va_list是char型的指针</span><br><span class="line">    char *s_string = malloc(300); //申请空间</span><br><span class="line">    va_start(ap, fmt); /找第一个可变形参的地址，并把地址赋给ap</span><br><span class="line">    vsprintf(s_string, fmt, ap); //类似sprintf函数</span><br><span class="line">    USART_String(USARTx, s_string);  //发送和整个字符串</span><br><span class="line">    va_end(ap); //结束</span><br><span class="line">    free(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的已经可以基本完成想要的内容了，可以多个串口同时使用printf，但是有一个问题，如果发送的字符串长度大于缓冲区的长度就会内存溢出，因此最好的办法就是在家一个参数，从而申请合适的大小空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//用串口写一个<span class="built_in">printf</span>函数</span><br><span class="line">void uprintf_s(USART_TypeDef *USARTx, uint32_t BuffSize,const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap; //typedef char *va_list; va_list是char型的指针</span><br><span class="line">    char *s_string = malloc(BuffSize); //申请空间</span><br><span class="line">    va_start(ap, fmt); //找第一个可变形参的地址，并把地址赋给ap</span><br><span class="line">    vsprintf_s(s_string,BuffSize, fmt, ap);	//类似sprintf_s函数</span><br><span class="line">    USART_String(USARTx, s_string); //发送和整个字符串</span><br><span class="line">    va_end(ap); 	//结束</span><br><span class="line">    free(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总的来说，printf是很好用，可以映射很多东西，比如LCD，OLED的驱动程序，只要配置好了并且设置了重定向都能用，可以说用途非常广泛，但是毕竟是系统库，占用内容还是比较多的，因此51单片机的话还是不用吧，STM32的话也是尽量用sprintf的形式，因为这样效率更高，内容占用也少。</p>
]]></content>
      <categories>
        <category>Embedded development</category>
      </categories>
      <tags>
        <tag>The C language</tag>
        <tag>SingleChip</tag>
        <tag>Uart</tag>
        <tag>51</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode画图神器--Drawio</title>
    <url>/2020/15.VSCode-Drawio/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>论文中画矢量图基本是刚需了，还有流程图也是经常用到的，微软家的Visio老是感觉怪怪的，画出来的图嵌入Word会自动缩放，因此字体大小也不对，所以我是直接放弃了一般用AI，前几天看VSCode的插件，发现VSCode居然也能画图，没错，你没看错，VSCode居然也能敲代码！</p>
<p>好了不开玩笑了，介绍今天的主角：Drawio。它本身是一个网页版的应用，跟我以前用的<a href="https://www.processon.com/" target="_blank" rel="noopener">Process On</a>差不多的，烦人的是他限制画图个数，后来就放弃了。后来发现了Draw i哦，而且一位来自德国前端工程师Henning Dieterichs成功将 <a href="http://draw.io" target="_blank" rel="noopener">draw.io</a> 的功能集成进了 VSCode，并打包成了插件供开发者下载使用，让你分分钟能用 VSCode 画出完美的流程图、思维导图与UML图，也有SVG矢量图的版本，十分好用，大家可以先去网页版试试功能，还可以设置语言，有简体中文。不仅如此，<a href="http://draw.io" target="_blank" rel="noopener">draw.io</a> 还支持将图形保存到 Google Drive、One Drive 等云端硬盘上，如果你正在用这些云盘的话那就太方便了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装非常简单，直接在VSCode的拓展商店里面搜索:VSCode Drawio，找到对应的拓展然后安装即可，应用比较大，安装可能比较慢，需要耐心等待一会。<br><img src="/images/Latex/3.1.png" alt="P3.1"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用也是非常简单，找一个目录新建一个文件夹，然后新建一个后缀是”.drawio”的文件，然后用VSCode打开文件夹，并且双击打开相应的文件即可，会自动识别的，在安装插件的预览页也可以看到相应的教程。</p>
<p>我个人简单使用了一段时间，个人觉得比Visio好用，图形也完全足够，做基本的图形我觉得完全足够，关键是超级简洁。唯一的遗憾是作者称目前的VSCode API暂时不稳定，期待下一次的更新。但是我也花了接近十张图了，目前暂时没发现任何问题，所以我也是会继续使用的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>VSCode是真的强大，编辑器的话现在已经基本用这一个了，而且拓展也挺多，真的很方便，强烈推荐！</p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>VsCode</tag>
        <tag>Drawio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VScode与MiKTex写论文</title>
    <url>/2020/14.VSCode-Latex/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>研究生了，于是写Latex的文档也比较多，之前同学们之间推荐的都是使用的Ctex，在 CTeX 套装刚刚问世之时，因其解决了繁琐的中文字体安装工作，所以广受欢迎，但是，一方面 CTeX 套装已经很久不更新，内里的宏包、工具陈旧。不过个人感觉太臃肿，而且安装要接近4G的样子，而且自带的编辑器界面是真的丑。于是就去扒了一下，发现其实就是使用MikTex编译和生成的，于是下载了MikTex的原版软件安装了试试，安装完了之后800M不到，虽然界面也比较难看，不过比Ctex好，而且非常简洁，还自带了PDF的阅读器，他的放大镜用起来非常舒服，感觉还是挺不错的，也用了一段时间，最近看到了用VSCode配置，发现真的是非常的简单和方便，而且VSCode这个软件真的是越用越爽，于是搜了一些资料然后自己尝试了一下，做了这个记录。</p>
<h1 id="软件安装和配置"><a href="#软件安装和配置" class="headerlink" title="软件安装和配置"></a>软件安装和配置</h1><p>软件有三个，分别是<a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">VSCode</a>,<a href="https://miktex.org/download" target="_blank" rel="noopener">MiKTeX</a>或者<a href="https://tug.org/texlive/" target="_blank" rel="noopener">Tex Live</a>选其一，还有<a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">Sumatra PDF</a>。</p>
<p>说说这三个软件，VSCode是微软推出的轻量级编辑器，个人觉得非常好用，目前我在Win10上的文本编辑基本都是这个软件，不管是C，还是Python都是非常好的，还能用SSH，十分推荐。其次是MiXTek和Tex Live，这两个我觉得都是差不多的，个人比较建议用MiKTex，他能设置自动获取的宏包，感觉还比较方便，安装起来也比较简洁，最后是Sumatra PDF，我个人认为最好的PDF阅读器，没有之一，要说缺点的话就是不能编辑，但是真的是非常清凉，而且打开速度非常快，重点是右键就是手抓模式，跟AD里面一样，所以用着很爽，还有就是他的缩放很到位。</p>
<p>软件的安装还是比较简单，我觉得没什么说的，重点就是添加环境变量。Win10 中将路径添加到环境变量中的步骤如下：右键我的电脑，然后选择”属性”，在左侧选择 “高级系统设置”，然后选择下方的”环境变量”，选择变量”Path”编辑，将需要添加的路径添加进去即可，如下所示：</p>
<p><img src="/images/Latex/2.1.png" alt="P2.1"></p>
<p>现在已经可以完整使用MiKTex编译tex文件并且生成PDF了，但是MiKTex的环境也不太友好，我们还是选择VSCode。要做的就是VSCode里面安装拓展来调用插件LaTeX Workshop插件，直接搜索和安装即可在使用VSCode里面写论文了。新建一个文件夹，在文件夹里面新建一个 .tex 文件，最好是英文的，然后试试下面的Hello World。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">Hello,world 1!</span><br><span class="line">Hello,world 2!</span><br><span class="line">Hello,world 3!</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>按”Ctrl + Alt + B”三个按键编译，会生成PDF文件，第一次可能比较慢，后面编译会快很多，这样基本环境就搭建好了。</p>
<h1 id="添加其他的编译方式"><a href="#添加其他的编译方式" class="headerlink" title="添加其他的编译方式"></a>添加其他的编译方式</h1><p>VSCode 默认添加了3个编译工具：分别是latexmk，pdflatex 和bibtex，这样会导致一些问题，比如中文编译报错， 添加参考文献”.bib”文件有问题等等。为了添加其他的编译方式（比如xelatex），我们需要修改LaTeX Workshop 的配置。打开LaTeX Workshop 配置的方法如下：在VSCode界面左上角，依次选择 “文件”-&gt;”首选项”-&gt;”设置”，这样就到了设置界面，然后在屏幕右上角找到文件上一个箭头的标志，弹出内容是”打开设置（JSON）”，点击会进入编辑内容，将下面的内容直接复制到看到的第一个大括号里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;latex-workshop.showContextMenu&quot;:true, &#x2F;&#x2F;右键菜单  </span><br><span class="line">&quot;latex-workshop.intellisense.package.enabled&quot;: true, &#x2F;&#x2F;根据加载的包，自动完成命令或包  </span><br><span class="line">&quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;,&#x2F;&#x2F;禁止保存文件时自动build  </span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;PDFLaTeX&quot;,</span><br><span class="line">     &quot;tools&quot;:[&quot;pdflatex&quot;]</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;PDFLaTeX with Shell Escape&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;pdflatex-with-shell-escape&quot;]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;XeLaTeX&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;xelatex&quot;]</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;XeLaTeX with Shell Escape&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;xelatex-with-shell-escape&quot;]</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot;]</span><br><span class="line">&#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;xelatex&quot;, &quot;bibtex&quot;, &quot;xelatex&quot;, &quot;xelatex&quot;]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;LaTeXmk&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;latexmk&quot;]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;BibTeX&quot;,</span><br><span class="line">     &quot;tools&quot;: [&quot;bibtex&quot;]</span><br><span class="line">   &#125;</span><br><span class="line"> ],</span><br><span class="line"> &quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">     &quot;args&quot;: [</span><br><span class="line">       &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">       &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">       &quot;-file-line-error&quot;,</span><br><span class="line">       &quot;-pdf&quot;,</span><br><span class="line">       &quot;-outdir&#x3D;%OUTDIR%&quot;,</span><br><span class="line">       &quot;%DOCFILE%&quot;</span><br><span class="line"> ],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">     &quot;args&quot;: [</span><br><span class="line">       &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">       &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">       &quot;-file-line-error&quot;,</span><br><span class="line">       &quot;%DOCFILE%&quot;</span><br><span class="line"> ],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;pdflatex-with-shell-escape&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">     &quot;args&quot;: [</span><br><span class="line">       &quot;--shell-escape&quot;,</span><br><span class="line">       &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">       &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">       &quot;-file-line-error&quot;,</span><br><span class="line">       &quot;%DOCFILE%&quot;</span><br><span class="line"> ],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">     &quot;args&quot;: [</span><br><span class="line">       &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">       &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">       &quot;-file-line-error&quot;,</span><br><span class="line">       &quot;%DOCFILE%&quot;</span><br><span class="line">   ],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;xelatex-with-shell-escape&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">     &quot;args&quot;: [</span><br><span class="line">       &quot;--shell-escape&quot;,</span><br><span class="line">       &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">       &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">       &quot;-file-line-error&quot;,</span><br><span class="line">       &quot;%DOCFILE%&quot;</span><br><span class="line"> ],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">     &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">     &quot;args&quot;: [&quot;%DOCFILE%&quot;],</span><br><span class="line">     &quot;env&quot;: &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ],</span><br><span class="line"> &quot;latex-workshop.latex.clean.fileTypes&quot;: [</span><br><span class="line"> &#x2F;&#x2F;设定清理文件的类型(ctrl+alt+c：清除辅助文件)    &quot;*.aux&quot;,</span><br><span class="line">   &quot;*.bbl&quot;,</span><br><span class="line">   &quot;*.blg&quot;,</span><br><span class="line">   &quot;*.idx&quot;,</span><br><span class="line">   &quot;*.ind&quot;,</span><br><span class="line">   &quot;*.lof&quot;,</span><br><span class="line">   &quot;*.lot&quot;,</span><br><span class="line">   &quot;*.out&quot;,</span><br><span class="line">   &quot;*.toc&quot;,</span><br><span class="line">   &quot;*.acn&quot;,</span><br><span class="line">   &quot;*.acr&quot;,</span><br><span class="line">   &quot;*.alg&quot;,</span><br><span class="line">   &quot;*.glg&quot;,</span><br><span class="line">   &quot;*.glo&quot;,</span><br><span class="line">   &quot;*.gls&quot;,</span><br><span class="line">   &quot;*.ist&quot;,</span><br><span class="line">   &quot;*.fls&quot;,</span><br><span class="line">   &quot;*.log&quot;,</span><br><span class="line">   &quot;*.fdb_latexmk&quot;,</span><br><span class="line">   &quot;*.nav&quot;,</span><br><span class="line">   &quot;*.snm&quot;,</span><br><span class="line">   &quot;*.synctex.gz&quot;,</span><br><span class="line">   &quot;*.bcf&quot;,</span><br><span class="line">   &quot;*.run.xml&quot;</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="/images/Latex/2.2.png" alt="P2.2"></p>
<p>保存好了之后重启VSCOde，用XeLaTex尝试下面编译带中文的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper]&#123;ctexart&#125; %CTEX报告文章格式</span><br><span class="line"></span><br><span class="line">\usepackage[top &#x3D; 2cm, bottom &#x3D; 2cm, left &#x3D; 2cm, right &#x3D; 2cm]&#123;geometry&#125; % 页边距</span><br><span class="line">\usepackage&#123;ctex&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">试试</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>如图所示，应该也是没多大问题的。<br><img src="/images/Latex/2.3.png" alt="P2.3"></p>
<h1 id="正向检索，反向检索和双向检索"><a href="#正向检索，反向检索和双向检索" class="headerlink" title="正向检索，反向检索和双向检索"></a>正向检索，反向检索和双向检索</h1><p>“反向检索”是什么意思呢，就是是同.tex文件生成的PDF，在查阅的时候双击，可以快速定位到原来tex文档的地方，可以用来快速且准确地修改。</p>
<h2 id="正向检索"><a href="#正向检索" class="headerlink" title="正向检索"></a>正向检索</h2><p>首先是正向检索，跟前面设置编译项相同，在VSCode里面设置JSON，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置预览方式</span><br><span class="line">&quot;latex-workshop.view.pdf.viewer&quot;: &quot;external&quot;,</span><br><span class="line">&quot;latex-workshop.view.pdf.ref.viewer&quot;: &quot;external&quot;,</span><br><span class="line">&#x2F;&#x2F; 设置外部PDF预览器</span><br><span class="line">&quot;latex-workshop.view.pdf.external.viewer.command&quot;: &quot;D:&#x2F;Sumatra&#x2F;SumatraPDF.exe&quot;,</span><br><span class="line">&quot;latex-workshop.view.pdf.external.viewer.args&quot;: [&quot;%PDF%&quot;],</span><br><span class="line">&#x2F;&#x2F; 配置Syntex的正向搜索(Latex-&gt;PDF)</span><br><span class="line">&quot;latex-workshop.view.pdf.external.synctex.command&quot;: &quot;D:&#x2F;Sumatra&#x2F;SumatraPDF.exe&quot;,</span><br><span class="line">&quot;latex-workshop.view.pdf.external.synctex.args&quot;: [</span><br><span class="line">  &quot;-forward-search&quot;,</span><br><span class="line">  &quot;%TEX%&quot;,</span><br><span class="line">  &quot;%LINE%&quot;,</span><br><span class="line">  &quot;-reuse-instance&quot;,</span><br><span class="line">  &quot;-inverse-search&quot;,</span><br><span class="line">  &quot;D:&#x2F;VSCode&#x2F;Code.exe D:&#x2F;VSCode&#x2F;resources&#x2F;app&#x2F;out&#x2F;cli.js -r -g %f:%l&quot;,</span><br><span class="line">  &quot;%PDF%&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>注意注意，路径要替换成自己的！！！路径要替换成自己的！！！路径要替换成自己的！！！</p>
<h2 id="反向检索"><a href="#反向检索" class="headerlink" title="反向检索"></a>反向检索</h2><p>下面是反向搜索，这个应该是SumatraPDF软件带的功能，在SumatraPDF的”设置”-&gt;”选项”中设置，添加的内容如下，还是注意：路径要替换成自己的！其次就是”&quot;和”/“的用法，在VSCode里面”&quot;是转义符，因此要表达”&quot;可以用”\“或者”/“来表达，大家按照我上面写的直接改路径即可，记得两个符号的不同。大家可以试试双击生成的PDF文字就可以体会到，非常实用！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;D:\VSCode\Code.exe&quot;  -g  &quot;%f:%l&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Latex/2.4.png" alt="P2.4"></p>
<h2 id="双向检索"><a href="#双向检索" class="headerlink" title="双向检索"></a>双向检索</h2><p>将光标移动到TeX文件的正文。ctrl+alt+x，找到”navigator,select and edit”，点击第一项”syncTeX from cursor”(或右键选择，或快捷键ctrl+alt+j)，会切换到PDF文件的相应位置并高亮显示。</p>
<p>其实VSCode里面也能立即展示PDF，感觉也挺好用的，也能自适应页宽，大家觉得不错的话也可以试试。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实这就是一个提高效率的方法，用着自己觉得舒服的编辑器来工作我觉得是非常舒服的事情，早期我一直用的Sublime，但是Sublime会弹出自动更新的提示，还有提醒捐赠，虽然弹窗次数不多但是也觉着不舒服，也不想网上找破解了，尊重一下别人的劳动成果嘛，毕竟VSCode是免费的，也挺好用的，整体就是这样，感觉VSCode+MiKTex是一个非常好的选择！最后感谢<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDI0ODEyNg==&mid=2247483750&idx=1&sn=f420aa6427e8a97b840fdabc473a6a01&chksm=ec2385b7db540ca16c369e560069eb4fd2070c6c112fcf76b4ad3346b815cf65bd49182eb752&mpshare=1&scene=1&srcid=&sharer_sharetime=1583150851810&sharer_shareid=d4bad27b7c193c89829e4b88500ddaa3&key=319ea6b0e73c8768b8eab405f52cc89f8f210f5bcbaff03642bc42f70d08d3278c27fbb7822a01ad902c59a409697039a914afdb65c8b07578cd0c5b51f07bf13927ac404b15c203771959f00970950e&ascene=1&uin=MTgxNzM5MjIyNA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AVMUEk2ansz%2B4XY5aceI%2Fas%3D&pass_ticket=FyB7qu%2Bm9yTy8UywTToOau5gRVKwoaGtbJ9qAyEuJdSemZx7ySdqKR2%2BMtt0SQtS" target="_blank" rel="noopener">VSCode中文社区的分享</a>！</p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>VsCode</tag>
        <tag>MiKTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓手机免root使用ADB命令卸载预装软件（去广告）</title>
    <url>/2020/13.ADB-Shell/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近很幸运的拿到一台小米6（还能再战三年），于是开始小折腾了半天，对比IOS的话感觉MIUI还是有很多好的地方的，不过系统广告实在难忍，在哪都有广告和推送，于是想到办法去广告。以前在<a href="https://www.52pojie.cn/" target="_blank" rel="noopener">我爱破解</a>看到过相关的内容，于是就去搜了一下，网上教程一大堆，于是在这里做一个小小的记录。本机部分参数如下：小米6，MIUI版本为MIUI10 9.9.3，基于安卓9的，刷的开发板但是没有开启root（官网上面的开发板暂时不会提示更新）。</p>
<h1 id="开发者选项"><a href="#开发者选项" class="headerlink" title="开发者选项"></a>开发者选项</h1><p>开发者选项是安卓手机调试必须开启的，小米的做法具体如下：打开 设置-&gt; 我的设备 -&gt; 全部参数，这里连点MIUI版本7下，然后会提示打开开发者选项，这样就可以打开USB调试了。</p>
<p>然后打开 设置 -&gt; 更多设置 -&gt; 开发者选项，这个时候默认是打开的，下滑找到“USB调试”的开关，将他打开即可，然后用数据线链接电脑等待弹出ADB调试的提示即可。</p>
<p><img src="/images/Android/P1.1.png" alt="P1"></p>
<h1 id="开始ADB调试"><a href="#开始ADB调试" class="headerlink" title="开始ADB调试"></a>开始ADB调试</h1><p>首先下载<a href="/uploads/ADBShell.zip" target="_blank">ADB工具包</a>，解压（英文目录最好）后在CMD打开，然后输入下面命令，如果返回设备信息说明连接上了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p><img src="/images/Android/P1.2.png" alt="P2"></p>
<p>若第一次不成功，手机上没有提示允许USB调试，那么就先确认USB调试打开，然后重新插拔数据线，然后输入命令试试。如果出现”Offline”，那么重启ADB，命令如下，然后重新插拔数据线，这样基本都能好。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">kill</span>-server</span><br><span class="line">adb start-server</span><br></pre></td></tr></table></figure>

<p>成功链接之后就能卸载应用了，这里对命令简单的说明一下，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm uninstall -k --user 0 packageName</span><br></pre></td></tr></table></figure>
<p>这个命令的意思就是将用户 0 的 packageName 应用卸载掉。<br>-k 表示保存数据，如不需要，可去掉 -k，–user 指定用户 id，Android 系统支持多个用户，默认用户只有一个，id=0。</p>
<p>我们可以到系统的应用设置里面看到 packageName ，如下图所示。下面是推荐卸载列出来的一些命令，其中包含广告的部分也在里面，直接用就行，不过需要注意不同版本的系统包名可能会有不同，因此还是系统的应用设置里面的 packageName 为准。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm uninstall --user 0 com.miui.systemAdSolution（小米系统广告解决方案，必删）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.analytics（小米广告分析，必删）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.gamecenter.sdk.service  （小米游戏中心服务）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.gamecenter  （小米游戏中心）</span><br><span class="line">adb shell pm uninstall --user 0 com.sohu.inputmethod.sogou.xiaomi  （搜狗输入法）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.player  （小米音乐）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.video  （小米视频）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.notes  （小米便签）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.translation.youdao  （有道翻译）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.translation.kingsoft  （金山翻译）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.email  （邮件）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.scanner  （小米扫描）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.hybrid  （混合器）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.bugreport  （bug 反馈）</span><br><span class="line">adb shell pm uninstall --user 0 com.milink.service  （米连服务）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.browser  （浏览器）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.gallery  （相册）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.yellowpage  （黄页）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.midrop  （小米快传）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.virtualsim  （小米虚拟器）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.payment  （小米支付）</span><br><span class="line">adb shell pm uninstall --user 0 com.mipay.wallet  （小米钱包）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.soundrecorder  （录音机）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.screenrecorder  （屏幕录制）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.wallpaper  （壁纸）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.voiceassist  （语音助手）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.fm  （收音机）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.touchassistant  （悬浮球）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.cellbroadcastreceiver  （小米广播）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.mitunes  （小米助手）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.pass  （小米卡包）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.thememanager  （个性主题管理）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.wallpaper  （动态壁纸）</span><br><span class="line">adb shell pm uninstall --user 0 com.android.wallpaper.livepicker  （动态壁纸获取）</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.klo.bugreport （KLO bug 反馈）</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.vipaccount  (小米社区)</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.miservice (服务反馈)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Android/P1.3.png" alt="P3"></p>
<p>！！！注意，下面的这些不能删除，会导致开不了机。尤其是应用商店，我自己有梯子所以用的Google Play商店，里面的App干净一些，所以没注意系统自带的应用商店删除了，但是它包含了系统的一些依赖，卸载之后不开机！如果实在手贱卸载了也可以去线刷，找到当前的系统ROM直接刷就行，也不会有数据丢失，只是会很麻烦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.miui.cloudservice  （小米云服务）</span><br><span class="line">com.xiaomi.account  （小米账户）</span><br><span class="line">com.miui.cloudbackup  （云备份）</span><br><span class="line">com.xiaomi.market  （应用市场）</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>说实话，从IOS到小米，我觉得MIUI还是挺好用的，虽然不如IOS，但是也能感受到安卓的开放，各种开源的APP和很多调试的需要的特定APP，大多都是安卓版本，广告的话卸载了之后我觉得也还算能用，MIUI确实已经很不错了。</p>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>ADB</tag>
        <tag>系统去广告</tag>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Premiere使两段视频分辨率一致</title>
    <url>/2020/12.PR-Resolution/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近学习剪视频，我下了一个4K的白蛇：缘起，然后学习B站大佬的<a href="https://www.bilibili.com/video/BV1HJ411h78u" target="_blank" rel="noopener">水墨转场</a>跟着做，下载了他的水墨素材，然后发现分辨率不对应，如下图所示，记录一下解决的办法。<br><img src="/images/Premiere/P1.png" alt="P1"></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>其实PR默认会把第一次导入的视频作为默认的分辨率来封装视频，大家看上面蒙面遮罩的效果，会看到分辨率的明显不同。默认的视频素材是4K的，但是作为遮罩的素材是1080P，所以有很多的内容没有遮上去。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>方法非常简单，只需要遮罩的素材，就是小分辨率的部分点击右键，出现一连串的选项菜单，选择“缩放为帧大小”，然后这个时候可以看预览就可以发现分辨率统一了，如下图所示。<br><img src="/images/Premiere/P2.png" alt="P2"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>东西其实还是比较简单的，其实“设为帧大小”貌似也可以，我也试过，但是人就有一些小问题，但是我下载的视频是4K而且是21：9的，设置“设为帧大小”只是将纵向拉成了，但是横向仍旧有问题，说明里面就是“设置为帧大小”，因此缩放是最保险的！</p>
<p>希望大家一起愉快的玩耍吧，一起愉快的用PR~</p>
]]></content>
      <categories>
        <category>Premiere</category>
      </categories>
      <tags>
        <tag>Premiere</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派使用SSH远程连接</title>
    <url>/2020/11.Raspberry-SSH/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>上一次说到了使用USB网卡连接Wi-Fi，这样可以正常联网和下载程序，但是有一点比较麻烦的是需要串口，是有线的连接，比较麻烦，而使用SSH的话就可以远程使用了，非常的方便，下面做一个简单地介绍。</p>
<h1 id="开启SSH"><a href="#开启SSH" class="headerlink" title="开启SSH"></a>开启SSH</h1><p>同使用串口访问一样，需要进行树莓派的基础设置，需要用到屏幕和键盘，先把USB网卡拔掉。启动后输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo raspi-cofig</span><br></pre></td></tr></table></figure>
<p>在配置界面中选择 5 Interfacing Options，回车确认，如下所示：<br><img src="/images/RaspberryPi/1.1Interfacing.png" alt="Interfacing"></p>
<p>然后继续选择 P2 SSH选项，回车确认，如下所示：<br><img src="/images/RaspberryPi/1.2Serial.png" alt="Serial"></p>
<p>然后一路继续即可，中间会提示弱密码不安全，直接忽略即可，选择开启之后就ok了。这个SSH服务是开机自启，后面不需要任何配置，然后插上USB网卡重启即可。</p>
<h1 id="SSH远程连接"><a href="#SSH远程连接" class="headerlink" title="SSH远程连接"></a>SSH远程连接</h1><p>首先确保主机和树莓派在同一网段，然后使用串口确定IP地址，这个在路由器惯例页面也能查到，最好是和Mac地址绑定，这样的话连着这个路由器的话IP地址不改变，获取IP地址的指令是 ifconfig ，如下所示：<br><img src="/images/RaspberryPi/1.6Ifconfig.png" alt="Ifconfig"></p>
<p>最后打开Putty直接连接即可，注意端口是22，如下所示：<br><img src="/images/RaspberryPi/1.7SSH.png" alt="SSH"></p>
<p>第一次连接之后有一个提示，点击确认即可，然后输入账号和密码就连接成功了，这样就能脱离串口使用无线连接啦，后面想做什么都非常方便。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于树莓派上手的体验就到这里了，下面开始搞事情，后面如果有哪些有意思的东西也会继续更新~</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>RaspberryPi</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派使用USB网卡连接无线网络</title>
    <url>/2020/10.Raspberry-USBPort/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>前面说过，我买到的这个树莓派是一代A+，没网口，Wi-Fi和蓝牙也都没有，就仅仅只有一个USB接口，资源少的可怜，怎么办呢，手里闲置的USB网卡刚刚好可以用到了。这个网卡是802.11/n的，免驱，插上就能用。于是网上爬了一些内容，也顺利连接了家里的Wi-Fi，感觉美滋滋~~</p>
<p>说明一下，一代树莓派A+的功耗非常低，但是线材还是要有保障的，今天刚刚连接USB网卡的时候开机一直提示低电压保护，虽然可以使用但是我担心后面会出问题，所以换了一根线，完美解决！参考威胁电子的统计资料，这个型号功耗在3.5W左右，但是这里建议还是使用5V2A及以上的供电！</p>
<p>好了，说了这么多废话，赶紧插上网卡准备折腾吧。</p>
<h1 id="硬件的相关信息"><a href="#硬件的相关信息" class="headerlink" title="硬件的相关信息"></a>硬件的相关信息</h1><p>首先查看使用的无线网卡，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># lsusb</span></span><br><span class="line">Bus 001 Device 002: ID 148f:7601 Ralink Technology, Corp. MT7601U Wireless Adapter</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<p>这里偷懒，直接使用的<font color=red>root</font>用户，可以看到，上面显示的 Device 002就是我的无线网卡，系统已经自带该网卡的驱动。</p>
<p>这里比较推荐使用新的系统，最好是直接去树莓派的官网下载，因为系统增加新网卡的支持，能免去编译驱动的麻烦，如果你的无线网卡在系统中无法识别，请自行编译安装驱动。</p>
<h1 id="查看已经连接的网络"><a href="#查看已经连接的网络" class="headerlink" title="查看已经连接的网络"></a>查看已经连接的网络</h1><p>指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># iwconfig</span></span><br><span class="line">wlan0     IEEE 802.11  ESSID:<span class="string">"OpenWrt"</span></span><br><span class="line">          Mode:Managed  Frequency:2.467 GHz  Access Point: 6C:FD:B9:CC:9B:1B</span><br><span class="line">          Bit Rate=72.2 Mb/s   Tx-Power=20 dBm</span><br><span class="line">          Retry short <span class="built_in">limit</span>:7   RTS thr:off   Fragment thr:off</span><br><span class="line">          Encryption key:off</span><br><span class="line">          Power Management:off</span><br><span class="line">          Link Quality=70/70  Signal level=-37 dBm</span><br><span class="line">          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0</span><br><span class="line">          Tx excessive retries:1420  Invalid misc:135   Missed beacon:0</span><br><span class="line"></span><br><span class="line">lo        no wireless extensions.</span><br></pre></td></tr></table></figure>

<p>这个<font color=red>OpenWrt</font> 就是连接的Wi-Fi，还有连接频段和信号质量等等信息，如果没有连接的话就不会显示这么多信息，而且是”off/any”这个状态。</p>
<h1 id="配置无线网络"><a href="#配置无线网络" class="headerlink" title="配置无线网络"></a>配置无线网络</h1><h2 id="扫描可见SSID"><a href="#扫描可见SSID" class="headerlink" title="扫描可见SSID"></a>扫描可见SSID</h2><p>使用如下指令扫描附近可见的SSID，并截取想要连接的无线路由器的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># iwlist wlan0 scan</span></span><br><span class="line">wlan0     Scan completed :</span><br><span class="line">          Cell 01 - Address: 6C:FD:B9:CC:9B:1B</span><br><span class="line">                    Channel:12</span><br><span class="line">                    Frequency:2.467 GHz (Channel 12)</span><br><span class="line">                    Quality=67/70  Signal level=-43 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">                    ESSID:<span class="string">"OpenWrt"</span></span><br><span class="line">                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s</span><br><span class="line">                              9 Mb/s; 12 Mb/s; 18 Mb/s</span><br><span class="line">                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s</span><br><span class="line">                    Mode:Master</span><br><span class="line">                    Extra:tsf=00000120c308241c</span><br><span class="line">                    Extra: Last beacon: 60ms ago</span><br><span class="line">                    IE: Unknown: 00074F70656E577274</span><br><span class="line">                    IE: Unknown: 010882848B960C121824</span><br><span class="line">                    IE: Unknown: 03010C</span><br><span class="line">                    IE: Unknown: 0706303020010C14</span><br><span class="line">                    IE: Unknown: 2A0100</span><br><span class="line">                    IE: Unknown: 32043048606C</span><br><span class="line">                    IE: IEEE 802.11i/WPA2 Version 1</span><br><span class="line">                        Group Cipher : CCMP</span><br><span class="line">                        Pairwise Ciphers (1) : CCMP</span><br><span class="line">                        Authentication Suites (1) : PSK</span><br><span class="line">                    IE: WPA Version 1</span><br><span class="line">                        Group Cipher : CCMP</span><br><span class="line">                        Pairwise Ciphers (1) : CCMP</span><br><span class="line">                        Authentication Suites (1) : PSK</span><br><span class="line">                    IE: Unknown: 0B050300A20000</span><br><span class="line">                    IE: Unknown: 2D1AEC0213FFFF000001000000000000000100000000000000000000</span><br><span class="line">                    IE: Unknown: 3D160C070600000000000000000000000000000000000000</span><br><span class="line">                    IE: Unknown: 7F080000000000000140</span><br><span class="line">                    IE: Unknown: DD180050F2020101010003A4000027A4000042435E0062322F00</span><br></pre></td></tr></table></figure>

<h2 id="设置SSID和对应密码"><a href="#设置SSID和对应密码" class="headerlink" title="设置SSID和对应密码"></a>设置SSID和对应密码</h2><p>使用如下命令密码生成SSID和对应的密码，复制内容备用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># wpa_passphrase OpenWrt Password</span></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">"OpenWrt"</span></span><br><span class="line">        <span class="comment">#psk="Password"</span></span><br><span class="line">        psk=583be43e0ffa97c1247d697a765edde350b37c98914307c46e87a00c2365dffc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<font color=red>OpenWrt</font>和<font color=red>Password</font>对应自己的Wi-Fi的SSID和密码。</p>
<p>然后通过重定向命令写入到文件备用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># wpa_passphrase MERCURY_4E1A blackcar &gt; ~/wifi.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="修改wpa-supplicant-conf"><a href="#修改wpa-supplicant-conf" class="headerlink" title="修改wpa_supplicant.conf"></a>修改wpa_supplicant.conf</h2><p>这一步需要管理员权限的，现在把内容粘贴到/etc/wpa_supplicant/wpa_supplicant.conf，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># less wifi.conf &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br></pre></td></tr></table></figure>

<p>或重定向的方式给 wpa_supplicant.conf 追加 wifi.conf ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># less wifi.conf &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置/etc/network/interfaces，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># nano /etc/network/interfaces</span></span><br></pre></td></tr></table></figure>

<p>下面是参考的配置，当网线和Wifi同时连接时会独立获得ip，wlan0的配置表示通过DHCP获取IP地址，默认的只到了第七行 source 这里，后面的内容复制过去保存即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please note that this file is written to be used with dhcpcd</span></span><br><span class="line"><span class="comment"># For static IP, consult /etc/dhcpcd.conf and 'man dhcpcd.conf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include files from /etc/network/interfaces.d:</span></span><br><span class="line"><span class="built_in">source</span>-directory /etc/network/interfaces.d</span><br><span class="line"></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">pre-up wpa_supplicant -B w -D wext -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">post-down killall -q wpa_supplicant</span><br></pre></td></tr></table></figure>

<h2 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h2><p>设置完成后保存退出，并重启树莓派的的网络：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># /etc/init.d/networking restart</span></span><br><span class="line">root@raspberrypi:~<span class="comment"># ifup wlan0</span></span><br></pre></td></tr></table></figure>

<p>我看到这里前面的都完满成功，但是Wi-Fi就是连不上，有一点点懵，最后干脆使用重启大法，后期之后就好啦！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<h1 id="查看连接后信息"><a href="#查看连接后信息" class="headerlink" title="查看连接后信息"></a>查看连接后信息</h1><p>连接成功后，用iwconfig查看信息，然后用ifconfig查看可知获得IP地址，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~<span class="comment"># ifconfig</span></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 2  bytes 78 (78.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2  bytes 78 (78.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::2232:33ff:fec7:185b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 20:32:33:c7:18:5b  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 19440  bytes 27371475 (26.1 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 11646  bytes 1101351 (1.0 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里就全部结束了，按照惯例还是感谢看到的各路大神的分享，分别有：<a href="https://www.jianshu.com/p/35be946c04c7" target="_blank" rel="noopener">phantomvk
</a> 的简书，<a href="https://blog.csdn.net/brightming/article/details/50365228" target="_blank" rel="noopener">brightming</a>、<a href="https://blog.csdn.net/weixin_33918357/article/details/92090085" target="_blank" rel="noopener">weixin_33918357</a>和<a href="https://blog.csdn.net/hustsselbj/article/details/45866773" target="_blank" rel="noopener">hustsselbj</a>在CSDN上的分享，十分感谢！</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>RaspberryPi</tag>
        <tag>USBPort</tag>
        <tag>Wi-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用串口终端访问树莓派</title>
    <url>/2020/09.Raspberry-Serial/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近天天在家也没事儿干，淘宝倒是逛的挺多的，这两天看到一家店，本来想买一个猫盘组一台NAS的，最终只买了一个OpenWrt软路由和一块树莓派。说起这个树莓派那就很有意思了，一代A+，只有一个USB口，一个HDMI，一个音频输出好一个MicroUSB供电，没有带网口，因此操作起来就比较麻烦了，但是，记住但是，真的便宜，只要38块RMB，还是512M的内存，然后开始了今天的内容，使用串口访问树莓派。这样做的好处是省出来那个USB口，后来知道可以接免驱的USB网卡，刚刚好，开启SSH的话串口都不需要，美滋滋<del>~</del></p>
<h1 id="配置串口终端"><a href="#配置串口终端" class="headerlink" title="配置串口终端"></a>配置串口终端</h1><p>首先开机，用HDMI连接屏幕，HSB接口连接键盘，这样才能开始后续的工作。开机输入密码进入系统之后要<font color=red>查看串口设备</font>。从树莓派官网可知，串口终端设备节点名为ttyS0，但是实际却不是，但是明确的一点是系统默认不开启串口，如果以前没有开启过的话那肯定是关闭的！</p>
<p>下面是<font color=red>打开串口终端</font>，在树莓派终端使用root权限执行如下命令以启动配置界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo raspi-cofig</span><br></pre></td></tr></table></figure>

<p>在配置界面中选择 5 Interfacing Options，回车确认，如下所示：<br><img src="/images/RaspberryPi/1.1Interfacing.png" alt="Interfacing"></p>
<p>然后继续选择 P6 Serial选项，回车确认，如下所示：<br><img src="/images/RaspberryPi/1.2Serial.png" alt="Serial"></p>
<p>之后左右键移动光标选择 Yes，回车确认，如下所示：<br><img src="/images/RaspberryPi/1.3Yes.png" alt="Yes"></p>
<p>全部完成之后重启树莓派即可，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure>

<p>重启的过程中仔细看可以看到开启串口的相关字符，后面直接用串口连接即可。</p>
<h1 id="串口硬件连接"><a href="#串口硬件连接" class="headerlink" title="串口硬件连接"></a>串口硬件连接</h1><p>现在只需要使用USB转TTL转接线连接PC和树莓派即可使用。树莓派40Pin脚示意图如下所示：<br><img src="/images/RaspberryPi/1.4GPIO.png" alt="GPIO"></p>
<p>串口的连接规则应该都比较熟悉，GND对应连接，RX和TX互换，即树莓派的RX连接USB串口的TX，树莓派的TX连接USB串口的RX，5V的引脚不连，因为有USB供电。</p>
<h1 id="使用串口工具访问树莓派"><a href="#使用串口工具访问树莓派" class="headerlink" title="使用串口工具访问树莓派"></a>使用串口工具访问树莓派</h1><p>最后的已经很简单了，直接使用终端软件连接即可，我使用的是Putty，查到串口号然后波特率设置为115200就可以直接连接了，这个时候会卡在登陆界面，输入用户名和密码就ok，如下图所示，这样就能通过串口直接访问树莓派了。<br><img src="/images/RaspberryPi/1.5Putty.png" alt="Putty"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>刚刚拿到的树莓派资源比较少，还好了解了一些相关的东西，并且在实际用的过程中参考了很多教程分享，十分的感谢，这里也是尽量列出来，分别有：<a href="https://zhuanlan.zhihu.com/p/38853178" target="_blank" rel="noopener">晒月亮的孩子</a>的支护分享，<a href="https://blog.csdn.net/messidona11/article/details/71514215" target="_blank" rel="noopener">安翔</a>的CSDN博客，<a href="http://www.waveshare.net/" target="_blank" rel="noopener">微雪电子</a>的教程贴，还有很多其他零碎的教程分享，真的非常感谢！</p>
<p>下一篇将介绍合理使用这个宝贵的USB口，使用免驱的USB网卡。</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>RaspberryPi</tag>
        <tag>Serial</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex参考文献双栏对齐</title>
    <url>/2020/08.Latex-References/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>参考文献部分，如果在最后单页而且是单栏就会非常不好看，双栏就会好很多，效果如下。其实现的方法非常简单，有两种，介绍如下<br><img src="/images/Latex/1.1Ref.png" alt="Ref"></p>
<h1 id="方法一：balance"><a href="#方法一：balance" class="headerlink" title="方法一：balance"></a>方法一：balance</h1><p>首先在开头引用”<font color=red>balance</font>“，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;balance&#125;</span><br></pre></td></tr></table></figure>

<p>然后在文章末尾，参考文献之前的部分加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\balance</span><br></pre></td></tr></table></figure>

<p>这样就可以了，编译一下就有可以了，亲测有效！</p>
<h1 id="方法一：flushend"><a href="#方法一：flushend" class="headerlink" title="方法一：flushend"></a>方法一：flushend</h1><p>这个方法更简单，直接在开头引用即可，更加方便快捷，也是亲测有效！添加的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;flushend&#125;</span><br></pre></td></tr></table></figure>

<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>本人对Latex使用也没有那么精炼，碰到问题也是基本在网上爬各种教程，文章参考了<a href="https://www.cnblogs.com/qq952693358/p/9445756.html" target="_blank" rel="noopener">Wasdns的简书</a>，表示非常感谢。</p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Termux安装KODExplorer实现可以内网文件共享的文件服务器（UI简洁，代码高亮）</title>
    <url>/2020/07.Termux+KODExplorer/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>之前收手机端Termux安装的Ubuntu已经放在家里装路由器的盒子里面了，一般是不会在拿出来了，但是要写一些Python的代码，我对VIM又不熟悉，而且经常为退出而烦恼，怎么办呢？最近看到B站上面以为大佬的分享，搭建了KODExplorer文件服务器，在网页即可执行很多操作，而且他的编辑器支持代码高亮，局域网内的文件共享，视频在线播放等等一系列的功能，个人感觉非常好用，在这里做一个记录。</p>
<h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><p>首先是Git，因为需要Git下载KODExplorer的资源，安装Git的指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y git</span><br></pre></td></tr></table></figure>

<p>其次是php的安装，指令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y php</span><br></pre></td></tr></table></figure>

<p>上面的install都附带了 -y，及默认安装，不会弹出那个确认的提示。</p>
<h1 id="下载KODExplorer文件服务器"><a href="#下载KODExplorer文件服务器" class="headerlink" title="下载KODExplorer文件服务器"></a>下载KODExplorer文件服务器</h1><p><a href="https://gitee.com/kalcaddle/KODExplorer" target="_blank" rel="noopener">KodExplorer</a>可道云，原名芒果云，是基于Web技术的私有云和在线文件管理系统，是一款快捷高效的私有云和在线文档管理系统，为个人网站、企业私有云部署、网络存储、在线文档管理、在线办公等提供安全可控，简便易用、可高度定制的私有云产品。采用windows风格界面、操作习惯，无需适应即可快速上手，支持几百种常用文件格式的在线预览，可扩展易定制。GPL v3开源协议。</p>
<p>个人觉得KodExplorer非常好用，不仅仅因为是Windows风格的操作，更有可以管理各种文件，而且Termux内部的目录也可以看的一清二楚，非常方便而且实用。在Termux安装的指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/kalcaddle/KODExplorer.git</span><br></pre></td></tr></table></figure>

<p>下载完成之后给权限，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod -Rf 777 ./KODExplorer/*</span><br></pre></td></tr></table></figure>

<p>最后是启动KODExplorer文件服务器。首先是进入KOEExplorer文件夹，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> KodExplorer</span><br></pre></td></tr></table></figure>

<p>此时使用ls指令可以查看相应的文件，然后使用php打开一个端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -S 192.168.1.101:8233 -t .</span><br></pre></td></tr></table></figure>

<p>这里的IP地址就是安装Termux本机的IP，最好别写localhost，因为使用真实IP的话可以在局域网的设备浏览器直接输入【IP+端口号】就可以访问到，而且真的是而且真的是美爆了，有毛玻璃效果！！！具体的效果如下：<br><img src="/images/Termux-Ubuntu/4.0.png" alt="KODExplorer"></p>
<p>如果使用乃往穿透就是个人服务器了，用来写Python实现一些小功能美滋滋，或者前端的html，MD也都是再好不过了！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>感谢<a href="https://www.bilibili.com/video/av89221670" target="_blank" rel="noopener">Coldwith</a>的分享，虽然他在视频中说失败了有问题，但是我这边成功实现了，2333~~</p>
]]></content>
      <categories>
        <category>Termux</category>
      </categories>
      <tags>
        <tag>Termux</tag>
        <tag>KODExplorer</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>通过更改Hosts解决Github进不去</title>
    <url>/2020/06.GitHub-SpeedUp/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>最近在家上GitHub还算比较多，但是发现经常进不去，最近的梯子也进本都挂了，导致GitHub有时候进不去，然后去网上搜了很多办法，发现效果还比较好，在这里做一个小小的总结和分享。</p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>今天实在看到大佬<a href="https://space.bilibili.com/20259914" target="_blank" rel="noopener">稚晖君</a>开源的项目很激动，转手去GitHub却发现打不开，然后直接F12走起看了下network，发现和网上说的一样，很多域名都是指向：github.global.ssl.fastly.net，因为我们的互联网高墙的原因当然是无法请求成功的，于是想到了改Hosts文件，不同的系统Hosts文件地址如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows系统hosts位于    C:\Windows\System32\drivers\etc\hosts   </span><br><span class="line">Android系统hosts位于    &#x2F;etc&#x2F;hosts</span><br><span class="line">Mac系统hosts位于        &#x2F;etc&#x2F;hosts</span><br><span class="line">IOS系统hosts位于        &#x2F;etc&#x2F;hosts</span><br><span class="line">Linux系统hosts位于      &#x2F;etc&#x2F;hosts</span><br><span class="line">绝大多数Unix系统都是在   &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p>用管理员权限打开Hosts文件，添加如下整合多人的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">74.125.237.1 dl-ssl.google.com</span><br><span class="line">74.125.128.95 ajax.googleapis.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.252.131 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br><span class="line">173.194.127.200 groups.google.com</span><br></pre></td></tr></table></figure>

<p>最后保存，重启浏览器即可。</p>
<h1 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h1><p>这个我基本上是参考网上的教程，非常感谢他们的分享，我在这里知识做一个小小的整合。具体参考的如下：<a href="https://blog.csdn.net/lusic01/article/details/54343828" target="_blank" rel="noopener">lusic01</a>的CSDN博客和<a href="https://jingyan.baidu.com/article/7908e85cecb8d7af481ad281.html" target="_blank" rel="noopener">百度经验</a>。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Termux给旧手机安装Ubuntu</title>
    <url>/2020/05.Termux/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>今年武汉的疫情非常严重，已经好多天没有出门了，东西也有好多都在学校，有点想搞事情，本身想买一个树莓派跑跑Ubuntu玩玩的，快递实在是太慢了，而且回家的大东西就带了电脑，其他的硬件基本都没有，没有办法只能从身边的旧手机入手了。我手上有两个旧的，一个是小米Note，说实话我非常喜欢的，外形和手感都非常好，但是换屏之后屏幕跳屏（后来在我调试的过程中忍不了给摔了2333）；另一台是荣耀8，华为的BL锁现在不能解开了，因此没有Root权限（感觉华为这件事儿很恶心）。我花了好长时间去解锁（其实就是不想去淘宝花30块钱），但是都没有成功，因此一直都搁置在，今天还是给拿出来了试试，终于成功在没有root权限的情况下安装了ubuntu，并且通过SSH连接上去了，可以跑一些Python程序，感觉还是很开心的，下面说说具体的过程。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>Android手机</li>
</ul>
<p>这个应该是不用说明的，Android系统本身也是基于Linux的，不用多言。其实Iphone也是可以使用SSH连接并使用一部分Linux指令的，但是需要越狱环境，而且指令能用的也非常少，就不多介绍了。相较于树莓派和其他的单板机，旧Android手机的优势还是非常大的。首先是Wi-Fi和蓝牙肯定是都带的，而且基本都不差；其次是内存和运存，现在而言一般都有16G的吧，比树莓派，香橙派等用的内存卡肯定是好很多的吧，最后是运存，2G至少也有吧；特别是CPU，这几年手机CPU的快速发展，可以说三年前的千元机CPU绝大部分都比树莓派3B强，因此性能也是不用担心的。</p>
<ul>
<li>软件：Termux </li>
</ul>
<p>关于软件的使用，我最终选择的是<a href="https://termux.com/" target="_blank" rel="noopener">Termux</a>。我前期三种方案，分别是：Androidterm + Busubox，Linux deploy + Busubox和Termux + AnLinux。但是前两个都是需要Root权限的，前期我的小米Note刷了开发板成功获取了Root，成功使用Androidterm + Busubox安装好了，非常感觉各位大神提供的镜像，资源我打包好了，<a href="https://pan.baidu.com/s/1Vv8iRk2jSa2qRkkngfYJGw" target="_blank" rel="noopener">如下</a>，感觉这个应该是最好的方案，毕竟是有权限的，想干嘛就干嘛（结局挺惨，跳屏有一点受不了，装SSH一直乱动我生气直接给摔了扔了）。其次是Linux deploy，这个也是十分有名的，我没有测试过，但是应该也是很不错的。最后是Termux + AnLinux的方案，这个对于没有Root权限的用户而言是最好的选择，安装Ubuntu Core，跑一下Python还是美滋滋的，下面我都是以Termux + AnLinux进行具体的说明。</p>
<h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>这个本身需要复制指令，因此先写了安装Ubuntu的过程，其实我个人更推荐的是使用SSH先连接到Termux，然后再执行指令安装ubunutu，这样的话可以完全不用AnLinux，因为指令在教程中已经给出了。</p>
<h2 id="首先安装软件"><a href="#首先安装软件" class="headerlink" title="首先安装软件"></a>首先安装软件</h2><p>Termux和AnLinux安装包已经打包好，<a href="https://pan.baidu.com/s/1Irz7ZZgr4YRP5BvIcpjrSA" target="_blank" rel="noopener">地址如下</a>。下载完成之后直接安装即可，软件比较小，应该能够很快的安装上，安装完成的两个图标如下所示。然后依次打开和运行即可(Anlinux在安装完成之后可以禁止联网，因为有广告)。<img src="/images/Termux-Ubuntu/3.1.png" alt="图标"></p>
<h2 id="用Termux安装Ubuntu"><a href="#用Termux安装Ubuntu" class="headerlink" title="用Termux安装Ubuntu"></a>用Termux安装Ubuntu</h2><p>首先打开AnLinux，首先看到的是仪表盘，下左图，然后点击“选择”，勾选Ubuntu，这里的系统看个人需求，我比较喜欢ubuntu，确定之后就可以复制指令了，最后点击“启动”便会启动Termux，将刚刚的指令复制过去并执行就可以了，它会下载相应的文件（如果可以，最好使用科学上网），具体内容如图所示。<img src="/images/Termux-Ubuntu/3.2.png" alt="AnLinux"></p>
<h2 id="在Termux安装Ubuntu并启动"><a href="#在Termux安装Ubuntu并启动" class="headerlink" title="在Termux安装Ubuntu并启动"></a>在Termux安装Ubuntu并启动</h2><p>在AnLinux转到Termux的时候会初始化，下左图。此时必须联网，因为要下载相应的文件。在安装Ubuntu之前需要执行两个操作：</p>
<p>申请读写权限，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">termux-setup-storage</span><br></pre></td></tr></table></figure>

<p>更新一下，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>


<p>更新之后即可执行AnLinux复制过来的指令，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg install wget openssl-tool proot -y &amp;&amp; <span class="built_in">hash</span> -r &amp;&amp; wget https://raw.githubusercontent.com/EXALAB/AnLinux-Resources/master/Scripts/Installer/Ubuntu/ubuntu.sh &amp;&amp; bash ubuntu.sh</span><br></pre></td></tr></table></figure>
<p>在Termux执行的结果如下，这个过程可能执行时间教程，如果有科学上网最好开启。完成之后会输入【ls】指令可以看到如下，下右图。<img src="/images/Termux-Ubuntu/3.3.png" alt="Termux">。</p>
<p>打开Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-ubuntu.sh</span><br></pre></td></tr></table></figure>
<p>在下面看到 root@localhost 就知道进入Ubuntu了，这样就可以愉快的玩耍啦~</p>
<h2 id="使用SSH连接Termux"><a href="#使用SSH连接Termux" class="headerlink" title="使用SSH连接Termux"></a>使用SSH连接Termux</h2><h3 id="安装openssh"><a href="#安装openssh" class="headerlink" title="安装openssh"></a>安装openssh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install openssh</span><br></pre></td></tr></table></figure>

<h3 id="启动sshd服务"><a href="#启动sshd服务" class="headerlink" title="启动sshd服务"></a>启动sshd服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshd</span><br></pre></td></tr></table></figure>

<h3 id="添加公钥信息"><a href="#添加公钥信息" class="headerlink" title="添加公钥信息"></a>添加公钥信息</h3><p>此操作在PC端，将生成的id_rsa.pub复制到存在于/sdcard/目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<h3 id="添加公钥信息到手机"><a href="#添加公钥信息到手机" class="headerlink" title="添加公钥信息到手机"></a>添加公钥信息到手机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">cp /sdcard/id_rsa.pub ./</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<p>此时已经完成SSH的配置了，下面还需要获取相关信息。</p>
<h3 id="获取相关信息"><a href="#获取相关信息" class="headerlink" title="获取相关信息"></a>获取相关信息</h3><ul>
<li><p>获取登录的用户名<br>会返回当前的用户名，最好不要是运行ubuntu时的root，一般是【u0_axxx】这样的格式，后面的示例为：u0_a118</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前的ip<br>PC端要跟手机端在同一网段，选取wlan0中的inet addr的地址即可。一般路由器分配的地址都是192.168.0.xxx这样的，后面的示例为：192.168.1.101</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置连接的密码<br>就是当前账户的密码，用于登录SSH的确认，需要输入两次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接SSH<br>默认端口不是22二十8022，这个一定要注意</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh u0_a118@192.168.1.101 -p 8022</span><br></pre></td></tr></table></figure>
<p>连接成功的界面如下所示：<img src="/images/Termux-Ubuntu/3.4.png" alt="SSH"></p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>前文的文件分享的百度云密码都是：2333。最后感谢网上看到的相关教程，分别有<a href="http://blog.lujun9972.win/blog/2018/01/24/%E4%BD%BF%E7%94%A8termux%E6%8A%8Aandroid%E6%89%8B%E6%9C%BA%E5%8F%98%E6%88%90ssh%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">DarkSun的个人博客</a>，520的罗的<a href="https://blog.51cto.com/gt520/2134487" target="_blank" rel="noopener">博客</a>，<a href="https://blog.csdn.net/u010164190/article/details/78831069" target="_blank" rel="noopener">慢慢的燃烧</a>、<a href="https://blog.csdn.net/zhangbangqian/article/details/82019175" target="_blank" rel="noopener">我是MONEY呀</a>、<a href="https://www.cnblogs.com/root1/p/9250678.html" target="_blank" rel="noopener">老板_来三斤荔枝</a>的博客，中间还有一些早期看到的教程，真的非常感谢！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Termux</tag>
        <tag>AnLinux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>HitMan Tube拟辉光钟制作记录</title>
    <url>/2020/01.HitMan-Tube/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看到B站大佬做了一个拟辉光钟，并且恰好我的同学<a href="http://www.nixieworld.com/" target="_blank" rel="noopener">Sadudu</a>也在做辉光钟，于是就正好一起做了一下这个用LED模拟的辉光钟，不为啥，就是使用的是LED，便宜并且寿命长，下面是效果图：<br><img src="/images/RaspberryPi/2.1.png" alt="2.1">。</p>
<p>相信大家看到这个肯定也是比较有能力的，因此我下面就简单介绍硬件和微信小程序的设计，重点还是就核心的代码的分享，分别是STM32单片机的WS2812B驱动程序和微信小程序的BLE通讯程序，保证可用！！！</p>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>自从我看到了以后我就一直在思考他是一个怎么样的东西。由于我看了辉光管的实物，知道是一层一层的电热丝结构，于是就想是LED隔开每一层，然后单独点亮即可，当时想到这个一晚上都没有睡着呢！但是单独控制每个LED有比较麻烦，如果是单片机IO用PWM调光的话可能会使用非常多的锁存器，电路设计较为麻烦，成本也会一定程度增加，经过一番调研（其实就是问的我的几个同学），最终确定了WS2812B这个方案，这个LED是单总线的，我们看到的圣诞节灯带或者是家庭装修的大部分就是用的这个，他可以一直向后链接，只需要在程序里面设计即可。选定了光源的方案，我觉得了解的人一般也都有一定的开发基础，而且这个链接起来非常简单，随便找就可以看到电路图，就不展示了，下面决定开源一下驱动，我是使用的STM32来设计的，并且是原子的库，没有使用HAL库。驱动的思路是定时器加上DMA，因为这个单总线对时间要求比较严格，很多都是微秒级别的操作，因此用DMA会好很多，具体的操作<a href="https://myoschain.com/blog/131078716791980032" target="_blank" rel="noopener">参考如下</a>。</p>
<h1 id="微信小程序设计"><a href="#微信小程序设计" class="headerlink" title="微信小程序设计"></a>微信小程序设计</h1><p>在PC段直接通信即可，但是每次使用电脑的确很不方便，于是想到了APP，但是安卓和IOS需要开发两版APP的话我觉得工作量还是比较大的，经过一番调研（还是和我的几个同学讨论），最终确定了使用微信小程序的方案。于是通信的方式又需要重新选定，由于IOS的微信小程序调用蓝牙的API的时候有一定的限制，具体请看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/device/bluetooth.html" target="_blank" rel="noopener">官方文档</a>，解决方案就是固定蓝牙的名称，通过名称确定设备，我设计了一个简单的界面，如下所示.做一个声明，由于微信小程序不能本地上传图片，只能使用网络地址的图片，我这里使用的是B站的<a href="https://space.bilibili.com/6823116/album" target="_blank" rel="noopener">壁纸娘的相簿</a>。<br><img src="/images/RaspberryPi/2.2.png" alt="2.2"><br><img src="/images/RaspberryPi/2.3.png" alt="2.3"></p>
<p>下面开始微信小程序的学习，于是到B站找到相应的课程学习。由于以前学过网页设计，并且也管理了实验室的网站，通过一段时间学习很快就上手了。微信小程序的连接只能连接BLE，就是低功耗蓝牙，我们以前电赛经常用到的HC 05，HC-06这样的设备是蓝牙3.0或以下的，BLE是蓝牙4.0协议，虽然他也向下兼容，但是其优秀的低功耗设计是搭建集体、家庭、个人网络的最佳选择。</p>
<p>这里贴一下蓝牙链接和通信的代码。我想吐槽一下，前期在网上找了很多的测试代码都不能用，最后还是使用官方的示例一步一步吃透才搞定的，以后看文档一定还是看官方的或者GitHub，CSDN上面的感觉有点鱼龙混杂的感觉，下面是BLE连接的代码：</p>
<p>首先是 ble.js 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const app = getApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> inArray(arr, key, val) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][key] === val) &#123;</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ArrayBuffer转16进度字符串示例</span><br><span class="line"><span class="keyword">function</span> ab2hex(buffer) &#123;</span><br><span class="line">    var hexArr = Array.prototype.map.call(</span><br><span class="line">        new Uint8Array(buffer),</span><br><span class="line">        <span class="keyword">function</span> (bit) &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="string">'00'</span> + bit.toString(16)).slice(-2)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">return</span> hexArr.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        devices: [],</span><br><span class="line">        connected: <span class="literal">false</span>,</span><br><span class="line">        chs: [],</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //首先是IOS指定设备的</span><br><span class="line">    <span class="function"><span class="title">connectBLE</span></span>() &#123;</span><br><span class="line">        //先初始化(在打开蓝牙之后也执行了搜寻的任务)</span><br><span class="line">        this.openBluetoothAdapter()</span><br><span class="line"></span><br><span class="line">        //然后列出所有的设备ID，安卓是Mac地址，IOS是设备的UUID</span><br><span class="line">        //console.log()</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //1.初始化蓝牙模块</span><br><span class="line">    <span class="function"><span class="title">openBluetoothAdapter</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"初始化蓝牙"</span>)</span><br><span class="line">        wx.openBluetoothAdapter(&#123;</span><br><span class="line">            success: (res) =&gt; &#123;         //初始化成功</span><br><span class="line">                console.log(<span class="string">'openBluetoothAdapter success'</span>, res)</span><br><span class="line">                this.startBluetoothDevicesDiscovery()      //开始搜寻周围的设备</span><br><span class="line">            &#125;,</span><br><span class="line">            fail: (res) =&gt; &#123;</span><br><span class="line">                wx.showModal(&#123;</span><br><span class="line">                    title: <span class="string">'温馨提示'</span>,</span><br><span class="line">                    content: <span class="string">'请检查手机蓝牙是否打开'</span>,</span><br><span class="line">                    showCancel: <span class="literal">false</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //2.开始搜寻周围的设备（一般在连接后使用wx.stopBluetoothDevicesDiscovery停止搜索）</span><br><span class="line">    <span class="function"><span class="title">startBluetoothDevicesDiscovery</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"开始搜寻周围的设备"</span>)</span><br><span class="line">        <span class="keyword">if</span> (this._discoveryStarted) &#123;</span><br><span class="line">            <span class="built_in">return</span>  //一直搜索</span><br><span class="line">        &#125;</span><br><span class="line">        this._discoveryStarted = <span class="literal">true</span></span><br><span class="line">        console.log(<span class="string">'***************************************'</span>)</span><br><span class="line">        </span><br><span class="line">        wx.startBluetoothDevicesDiscovery(&#123;</span><br><span class="line">            allowDuplicatesKey: <span class="literal">true</span>,           //允许重复上报同意设备（RSSI值可能会不同）</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">'startBluetoothDevicesDiscovery success'</span>, res)</span><br><span class="line">                this.onBluetoothDeviceFound()   //监听寻找到新设备的事件</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //3.监听寻找新设备的事件</span><br><span class="line">    <span class="function"><span class="title">onBluetoothDeviceFound</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"监听寻找新设备的事件"</span>)</span><br><span class="line">        wx.onBluetoothDeviceFound(<span class="keyword">function</span> (devices) &#123;</span><br><span class="line">            console.log(devices)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (devices.name == <span class="string">'HitManTube'</span>) &#123;</span><br><span class="line">                this.stopBluetoothDevicesDiscovery();</span><br><span class="line">                console.log(<span class="string">"device found"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        wx.onBluetoothDeviceFound((res) =&gt; &#123;</span><br><span class="line">            res.devices.forEach(device =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">"Name:"</span> + device.name)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!device.name &amp;&amp; !device.localName) &#123;</span><br><span class="line">                    <span class="built_in">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const foundDevices = this.data.devices</span><br><span class="line">                const idx = inArray(foundDevices, <span class="string">'deviceId'</span>, device.deviceId)</span><br><span class="line">                const data = &#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> (idx === -1) &#123;</span><br><span class="line">                    data[`devices[<span class="variable">$&#123;foundDevices.length&#125;</span>]`] = device</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[`devices[<span class="variable">$&#123;idx&#125;</span>]`] = device</span><br><span class="line">                &#125;</span><br><span class="line">                this.setData(data)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (device.name == <span class="string">"HitManTube"</span>) &#123;</span><br><span class="line">                    console.log(<span class="string">"找到相应的ID"</span>)</span><br><span class="line"></span><br><span class="line">                    this.createBLEConnection(device.name)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //4.连接BLE设备(可直接传入之前小程序连接的蓝牙设备)</span><br><span class="line">    createBLEConnection(e) &#123;</span><br><span class="line">        console.log(<span class="string">"开始连接设备！！"</span> + e)</span><br><span class="line">        const ds = e.currentTarget.dataset</span><br><span class="line">        const deviceId = ds.deviceId</span><br><span class="line">        const name = ds.name</span><br><span class="line">        wx.createBLEConnection(&#123;</span><br><span class="line">            deviceId,</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                this.setData(&#123;</span><br><span class="line">                    connected: <span class="literal">true</span>,</span><br><span class="line">                    name,</span><br><span class="line">                    deviceId,</span><br><span class="line">                &#125;)</span><br><span class="line">                this.getBLEDeviceServices(deviceId) //获取蓝牙设备所有服务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.stopBluetoothDevicesDiscovery()        //连接之后停止蓝牙搜索</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    createBLEConnection(founddeviceId) &#123;</span><br><span class="line">        console.log(<span class="string">"开始连接设备！！"</span> + e)</span><br><span class="line">        deviceId = founddeviceId</span><br><span class="line">        wx.createBLEConnection(&#123;</span><br><span class="line">            deviceId,</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                this.setData(&#123;</span><br><span class="line">                    connected: <span class="literal">true</span>,</span><br><span class="line">                    name,</span><br><span class="line">                    deviceId,</span><br><span class="line">                &#125;)</span><br><span class="line">                this.getBLEDeviceServices(deviceId) //获取蓝牙设备所有服务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.stopBluetoothDevicesDiscovery()        //连接之后停止蓝牙搜索</span><br><span class="line">    &#125;,</span><br><span class="line">    //5.停止寻找蓝牙设备(在连接之后调用，因为搜寻蓝牙设备比较耗费系统资源)</span><br><span class="line">    <span class="function"><span class="title">stopBluetoothDevicesDiscovery</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">"停止搜寻蓝牙设备"</span>)</span><br><span class="line">        wx.stopBluetoothDevicesDiscovery()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //6.获取蓝牙设备所有服务(serviceID)</span><br><span class="line">    getBLEDeviceServices(deviceId) &#123;</span><br><span class="line">        console.log(<span class="string">"获取蓝牙设备所有服务(service) "</span>)</span><br><span class="line">        wx.getBLEDeviceServices(&#123;</span><br><span class="line">            deviceId,</span><br><span class="line">            success: (res) =&gt; &#123;         //如果成功就所有的设备展示出来</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; res.services.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (res.services[i].isPrimary) &#123;</span><br><span class="line">                        this.getBLEDeviceCharacteristics(deviceId, res.services[i].uuid)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //7.获取蓝牙设备某个服务中所有特征值(characteristicID)</span><br><span class="line">    getBLEDeviceCharacteristics(deviceId, serviceId) &#123;</span><br><span class="line">        console.log(<span class="string">"获取蓝牙设备某个服务中所有特征值(characteristic) "</span>)</span><br><span class="line">        wx.getBLEDeviceCharacteristics(&#123;</span><br><span class="line">            deviceId,</span><br><span class="line">            serviceId,      //蓝牙服务 uuid，需要使用 getBLEDeviceServices 获取</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">'getBLEDeviceCharacteristics success'</span>, res.characteristics)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; res.characteristics.length - 1; i++) &#123;</span><br><span class="line">                    <span class="built_in">let</span> item = res.characteristics[i]</span><br><span class="line">                    //显示所有的特征值</span><br><span class="line">                    console.log(item)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (item.properties.read) &#123;</span><br><span class="line">                        wx.readBLECharacteristicValue(&#123;</span><br><span class="line">                            deviceId,</span><br><span class="line">                            serviceId,</span><br><span class="line">                            characteristicId: item.uuid,</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (item.properties.write) &#123;</span><br><span class="line">                        this.setData(&#123;</span><br><span class="line">                            canWrite: <span class="literal">true</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                        this._deviceId = deviceId</span><br><span class="line">                        this._serviceId = serviceId</span><br><span class="line">                        this._characteristicId = item.uuid</span><br><span class="line">                        this.writeBLECharacteristicValue()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (item.properties.notify || item.properties.indicate) &#123;</span><br><span class="line">                        wx.notifyBLECharacteristicValueChange(&#123;</span><br><span class="line">                            deviceId,</span><br><span class="line">                            serviceId,</span><br><span class="line">                            characteristicId: item.uuid,</span><br><span class="line">                            state: <span class="literal">true</span>,</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(res) &#123;</span><br><span class="line">                console.error(<span class="string">'getBLEDeviceCharacteristics'</span>, res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 操作之前先监听，保证第一时间获取数据</span><br><span class="line">        wx.onBLECharacteristicValueChange((characteristic) =&gt; &#123;</span><br><span class="line">            const idx = inArray(this.data.chs, <span class="string">'uuid'</span>, characteristic.characteristicId)</span><br><span class="line">            const data = &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (idx === -1) &#123;</span><br><span class="line">                data[`chs[<span class="variable">$&#123;this.data.chs.length&#125;</span>]`] = &#123;</span><br><span class="line">                    uuid: characteristic.characteristicId,</span><br><span class="line">                    value: ab2hex(characteristic.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data[`chs[<span class="variable">$&#123;idx&#125;</span>]`] = &#123;</span><br><span class="line">                    uuid: characteristic.characteristicId,</span><br><span class="line">                    value: ab2hex(characteristic.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.setData(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其次是 ble.wxml 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;wxs module=<span class="string">"utils"</span>&gt;</span><br><span class="line">module.exports.max = <span class="keyword">function</span>(n1, n2) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.max(n1, n2)</span><br><span class="line">&#125;</span><br><span class="line">module.exports.len = <span class="keyword">function</span>(arr) &#123;</span><br><span class="line">  arr = arr || []</span><br><span class="line">  <span class="built_in">return</span> arr.length</span><br><span class="line">&#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line">&lt;button bindtap=<span class="string">"openBluetoothAdapter"</span>&gt;开始扫描&lt;/button&gt;</span><br><span class="line">&lt;button bindtap=<span class="string">"stopBluetoothDevicesDiscovery"</span>&gt;停止扫描&lt;/button&gt;</span><br><span class="line">&lt;button bindtap=<span class="string">"closeBluetoothAdapter"</span>&gt;结束流程&lt;/button&gt;</span><br><span class="line">&lt;button bindtap=<span class="string">"connectBLE"</span>&gt;一键连接&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;view class=<span class="string">"devices_summary"</span>&gt;已发现 &#123;&#123;devices.length&#125;&#125; 个外围设备：&lt;/view&gt;</span><br><span class="line">&lt;scroll-view class=<span class="string">"device_list"</span> scroll-y scroll-with-animation&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;devices&#125;&#125;"</span> wx:key=<span class="string">"index"</span></span><br><span class="line">   data-device-id=<span class="string">"&#123;&#123;item.deviceId&#125;&#125;"</span></span><br><span class="line">   data-name=<span class="string">"&#123;&#123;item.name || item.localName&#125;&#125;"</span></span><br><span class="line">   </span><br><span class="line">   bindtap=<span class="string">"createBLEConnection"</span> </span><br><span class="line">   class=<span class="string">"device_item"</span></span><br><span class="line">   hover-class=<span class="string">"device_item_hover"</span>&gt;</span><br><span class="line">    &lt;view style=<span class="string">"font-size: 16px; color: #333;"</span>&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;view style=<span class="string">"font-size: 10px"</span>&gt;信号强度: &#123;&#123;item.RSSI&#125;&#125;dBm (&#123;&#123;utils.max(0, item.RSSI + 100)&#125;&#125;%)&lt;/view&gt;</span><br><span class="line">    &lt;view style=<span class="string">"font-size: 10px"</span>&gt;UUID: &#123;&#123;item.deviceId&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;view style=<span class="string">"font-size: 10px"</span>&gt;Service数量: &#123;&#123;utils.len(item.advertisServiceUUIDs)&#125;&#125;&lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view class=<span class="string">"connected_info"</span> wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;connected&#125;&#125;"</span>&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt;已连接到 &#123;&#123;name&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;view class=<span class="string">"operation"</span>&gt;</span><br><span class="line">    &lt;button wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;canWrite&#125;&#125;"</span> size=<span class="string">"mini"</span> bindtap=<span class="string">"writeBLECharacteristicValue"</span>&gt;写数据&lt;/button&gt;</span><br><span class="line">    &lt;button size=<span class="string">"mini"</span> bindtap=<span class="string">"closeBLEConnection"</span>&gt;断开连接&lt;/button&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;chs&#125;&#125;"</span> wx:key=<span class="string">"index"</span> style=<span class="string">"font-size: 12px; margin-top: 10px;"</span>&gt;</span><br><span class="line">    &lt;view&gt;特性UUID: &#123;&#123;item.uuid&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;view&gt;特性值: &#123;&#123;item.value&#125;&#125;&lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p>有了这两个文件应该就可以成功连接并且发送一定的数据了，想要自己发送相应的东西还是需要自定义相应的通讯协议，后面需要根据自己的需求来设计了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于这个开发就到这里了，很多文件可以到QQ群：1321653，我也是经过了群主和管理员的帮助才能顺利完成，而且里面的成员都是非常友好的，有问题大家也可以一起思考。最后呢感觉做这些还是非常有成就感的，非常开心，2333</p>
]]></content>
      <categories>
        <category>HitMan Tube</category>
      </categories>
      <tags>
        <tag>HitMan Tueb</tag>
        <tag>辉光管</tag>
        <tag>微信小程序</tag>
        <tag>蓝牙BLE</tag>
      </tags>
  </entry>
  <entry>
    <title>2020肺炎实时疫情图【置顶】</title>
    <url>/2020/00.WuHan/</url>
    <content><![CDATA[<iframe src="https://www.lovestu.com/api/project/cnmapyinqing/obj.php" height="500" frameborder="no" border="0" width="100%"> </iframe>


<p>来源：<a href="https://www.ghpym.com/2020cnyqt.html" target="_blank" rel="noopener">果核剥壳</a><br>实时数据来源：丁香医生</p>
]]></content>
      <tags>
        <tag>WuHan</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题的记录</title>
    <url>/2020/04.LeetCode/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本人闲来无事在LeetCode上面开始刷题，但是比较菜，没做出来很多，而且也基本上做的简单的题目，但是仍旧学习了很多知识，在这里做一个简单的记录，以后也会随时更新，也欢迎大家收看，放上<a href="https://github.com/Homepea7/LeetCode" target="_blank" rel="noopener">GitHub地址</a>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git上传本地代码到GitHub</title>
    <url>/2020/03.Git-Commit/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文仅仅是介绍几条简单的指令，将本地的代码上传到GitHub，免得老是忘记，因此写了这篇博文，内容比较简单。</p>
<h1 id="安装Git，创建码仓"><a href="#安装Git，创建码仓" class="headerlink" title="安装Git，创建码仓"></a>安装Git，创建码仓</h1><p>首先是安装软件和在GitHub上创建代码仓库，这个不做多的介绍，应该都比较熟悉。然后是需要将代码仓Clone到本地，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:Homepea7/LeetCode.git</span><br></pre></td></tr></table></figure>
<p>后面的地址就是自己代码仓的SSH，下载完成以后本地会有一个相应的文件夹，名称就是代码仓的名称。</p>
<h1 id="复制文件，准备上传"><a href="#复制文件，准备上传" class="headerlink" title="复制文件，准备上传"></a>复制文件，准备上传</h1><p>将需要上传的文件复制到刚刚Clone的文件夹下，接着在Git Bash中使用【cd XXX】命令进入该文件夹（XXX是刚刚的代码仓的名称）。</p>
<h1 id="执行命令，开始上传"><a href="#执行命令，开始上传" class="headerlink" title="执行命令，开始上传"></a>执行命令，开始上传</h1><p>分别执行如下三条指令，如下所示：</p>
<ol>
<li><p>将XXX文件夹下面的文件都添加进来（别忘记后面的”.”，而且add后面与”.”有空格）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
</li>
<li><p>填写提交信息，比如下列指令的”first commit”:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit  -m  <span class="string">"first commit"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把本地仓库push到github上面，如果以前没有上传SSH公钥的话需要输入帐号和密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>上传的操作肯定是经常需要用到的，也非常简单，希望以后可以不看这个记录就能熟练的使用git。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>commit code</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Hexo建站</title>
    <url>/2020/02.Hexo+Next/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直想做一个自己的网站，也买了域名，最开始看了果核的建站教程，觉得基于<a href="https://zh-cn.wordpress.com/" target="_blank" rel="noopener">WordPress</a>的非常方便，但是搭建除了买域名之外还需要虚拟主机，费用比较高。作为一名屌丝研究生呢，肯定是要选择便宜的呀，然后问了我<a href="http://begild.top/" target="_blank" rel="noopener">队友</a>，决定用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>试试。</p>
<p>最初它推荐的是国内的<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>上面建站，访问速度比<a href="https://github.com/" target="_blank" rel="noopener">Github</a>快，我也网站找了很多教程，很多人也都是这样说，因此我开始了很多的摸爬滚打，但是最后还是选择了Github，毕竟是全球最大的同性交友网站嘛，这里提一句在B站找到了一些教程用的Linux，我这里是用的Window10，其实在linux是一样的操作，只是相应的文件目录不一样而已。说到底呢其实主要是记录和学习用的，以后看到自己的博客可能也会觉得自己很有意思的吧。</p>
<h1 id="关于Hexo-Next主题的说明"><a href="#关于Hexo-Next主题的说明" class="headerlink" title="关于Hexo+Next主题的说明"></a>关于Hexo+Next主题的说明</h1><p>首先说明我也是参考了大部分的教程，非常感谢在CSDN，知乎，简书，B站和掘金上面看到的相关教程，在结语中有相应的列举，下面的工作都是自己之前做的一些工作截的图，也是比较新的内容。</p>
<p>然后说说Hexo，它是一款基于Node.js的静态博客框架，依赖少、易于安装使用，可以方便的生成静态网页托管在Github上。他的一些指令非常方便的生成静态网页，对于像Github和Coding这样能够生成静态网页的平台而言非常好用，关键在免费！Hexo的常见这是台湾人，因此对中文支持很好，而且全<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">开源</a>，主题非常好看，也可以进行非常多的个性化配置，一条指令可以直接同步到Github和Coding，非常好用。</p>
<p>其次是Next主题，Hexo支持很多主题风格，其中Next主题是Github上Star最多的主题，其一直在更新维护，支持非常多的外部插件和功能选项，关键是非常好看，配置起来也很简单，上手也快。</p>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>搭建步骤我都是非常简洁的去写，但是都会留一些截图具体说明，下面是几个具体的步骤：</p>
<ul>
<li>GitHub创建仓库</li>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>将 GitHub 和 Hexo 关联起来</li>
</ul>
<h2 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h2><p>登录到GitHub，如果没有<a href="https://github.com/" target="_blank" rel="noopener">Github</a>账号，如果没有的话就注册一个。如下图所示创建个人仓库，仓库名应该为：用户名.github.io，[注：这是固定写法]，比如我的仓库名为：Homepea7.github.io<br><img src="/images/recording-hexo/3.1.png" alt="仓库"></p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>Git是开源的分布式版本控制系统，我们网站在本地搭建好了，需要使用Git同步到GitHub上。安装后的效果就跟WIN10的CMD或者Linux的终端一样，都是执行的命令行，具体上传的过程后面会有具体的说明。关于Git的使用网上的教程很多，廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a>和<a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">Python教程</a>我都看过，需要一点点的基础，不过逻辑和说明都非常的详细，大家可以自己搜一下看看。从Git官网下载Git-安装包 ，下载后安装，在命令行输入git测试是否安装成功，安装成功后，将Git与GitHub账号绑定，鼠标右键打开Git Bash Here。</p>
<p><img src="/images/recording-hexo/3.2.1.png" alt="Git"></p>
<h3 id="设置GIT配置信息"><a href="#设置GIT配置信息" class="headerlink" title="设置GIT配置信息"></a>设置GIT配置信息</h3><p>安装了Git之后首先要设置user.name和user.email配置信息，具体如下所示（双引号也是需要的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure>

<h3 id="生成ssh密钥文件"><a href="#生成ssh密钥文件" class="headerlink" title="生成ssh密钥文件"></a>生成ssh密钥文件</h3><p>设置好了以后需要生成SSH密钥文件，方便上传网站。具体操作执行代码如下（双引号也是需要的）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure>

<p>执行完了之后直接三个回车即可，默认不需要设置密码 然后在目录【C:\Users\XXX.ssh】文件夹下面找到id_rsa.pub密钥，如下所示：<br><img src="/images/recording-hexo/3.2.2.png" alt="SSH"></p>
<h3 id="复制到Github"><a href="#复制到Github" class="headerlink" title="复制到Github"></a>复制到Github</h3><p>将前面得到的SSH内容全部复制到Github上面的<a href="https://github.com/settings/keys" target="_blank" rel="noopener">界面</a>即可。新建new SSH Key，Title为标题，随意填即可，如下图所示：<br><img src="/images/recording-hexo/3.2.3.png" alt="KEY"></p>
<p>在Git Bash检测GitHub公钥设置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

<p>如果下图说明成功：</p>
<p><img src="/images/recording-hexo/3.2.4.png" alt="SSHOK"></p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Hexo基于<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>，将官方的文件下下来直接安装即可。</p>
<p>检测Node.js是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>检测npm是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo就是博客的框架，这里需要在自己的电脑里创建一个文件夹，这里我命名为Hexo，Hexo框架与以后你自己发布的网站都在这个文件夹中，创建好后，进入文件夹中 -&gt; Git Bash Here -&gt; 使用npm命令安装Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>复制代码这个安装时间较长（耐心等待中），我在下载的过程中好几次都下不下来,因此也打包了<a href="https://pan.baidu.com/s/1Xb36YSWXF3NZ7LojWNsm9A" target="_blank" rel="noopener">整个项目文件</a>，下载解压可以直接进行下面的步骤，也包含了Next主题。安装/下载 完成后，初始化我们的博客，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init Hexo</span><br></pre></td></tr></table></figure>

<p>复制代码为了检测网站的雏形，分别按顺序输入一下三条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>复制代码完成后在浏览器输入: <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，可以看到我们写出的第一篇博文Hello World，里面有最基本的几个指令。</p>
<h2 id="将-Hexo-和-GitHub-Coding-关联起来"><a href="#将-Hexo-和-GitHub-Coding-关联起来" class="headerlink" title="将 Hexo 和 GitHub/Coding 关联起来"></a>将 Hexo 和 GitHub/Coding 关联起来</h2><p>在Hexo根目录里_config.yml文件成为站点配置文件，打开_config.yml修改deploy（yml文件是根据缩进来判断的，因此一定要注意空格的多少），具体的操作如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:Homepea7/Homepea7.github.io.git</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@e.coding.net:homepea/blog.git</span><br></pre></td></tr></table></figure>

<p>复制代码保存站点配置，其实就是然hexo知道你要把Hexo部署在哪个位置，很明显，我们部署在我们GitHub/Coding的仓库里，最后安装Git部署插件，在部署之前需要执行以下指令，让Hexo能够正确上传。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>复制代码这时，我们分别输入三条命令，即可在通过xxx.github.io看到我们的博客了，最后执行下列执行，分别是清理，重建页面和上传仓库三个操作，一般上传之后不能立马看到效果，需要等待十分钟左右。执行的指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h1 id="关于网站的美化"><a href="#关于网站的美化" class="headerlink" title="关于网站的美化"></a>关于网站的美化</h1><p>说实话我对好看的想法不多，只是想看起来能看，而且给妹子看她们觉得不丑就好了。我把我修改好的<a href="https://pan.baidu.com/s/1yTp2zblSl2IzA7T6ThQ4Sg" target="_blank" rel="noopener">next主题打包</a>好了，下载之后直接替换应该也是可以直接使用的。关于网上Next的主题优化的教程很多，相应的图标啊，图片啊什么的也有很多网站，我个人比较喜欢阿里的图标库，免费且很多很好看的图标。这里就不一一列举了，直接Google关键字【Next主题美化】即可。</p>
<p>这里有一点要指出来的就是Next主题自7.6.0版本开始，自动在首页对文章进行摘要描述作为前言文本的功能被移除，请自行安装第三方插件，或阅读 Hexo <a href="https://github.com/chekun/hexo-excerpt" target="_blank" rel="noopener">有关文档</a>。没有这个功能的话对导致主页上面是文章的全部内容，显得非常的杂乱，相应的处理方法也是非常简单，自行安装【 hexo-excerpt 】即可，如下所示：</p>
<h2 id="在博客目录下执行Git-Bash"><a href="#在博客目录下执行Git-Bash" class="headerlink" title="在博客目录下执行Git Bash"></a>在博客目录下执行Git Bash</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>

<h2 id="在站点配置文件-config-yml添加内容"><a href="#在站点配置文件-config-yml添加内容" class="headerlink" title="在站点配置文件_config.yml添加内容"></a>在站点配置文件_config.yml添加内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自动在首页对文章进行摘要描述作为前言文本</span></span><br><span class="line">excerpt:</span><br><span class="line">  depth: 3 <span class="comment">#摘要的内容多少</span></span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="在主题配置文件-config-yml确认开启"><a href="#在主题配置文件-config-yml确认开启" class="headerlink" title="在主题配置文件_config.yml确认开启"></a>在主题配置文件_config.yml确认开启</h2><p>查找字符excerpt_description 改为true，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line">excerpt_description: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后执行下列指令，重新生成一下静态网页就可以啦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h1 id="域名购买和解析"><a href="#域名购买和解析" class="headerlink" title="域名购买和解析"></a>域名购买和解析</h1><p>相信不少同学对生成的网页名称(xxx.github.io 或 xxx.coding.me)不满意，购买自己的域名也是需要相应的解析的，这个步骤比较简单，下面我也做一些介绍。具体分三步，如下：</p>
<ul>
<li>购买域名</li>
<li>仓库中添加CNAME文件并在文件中填写绑定的域名</li>
<li>添加域名解析</li>
</ul>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>前提是前面的利用Github或者Coding搭建已经完成了并且可以访问了，后面的操作才有意义。关于域名的购买，有免费的和收费的，免费的王章也是一搜一大把，但是作为自己个性化的东西我觉得还是付费的安全一些。我买的是<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a>的.top域名，别问为什么，问就是穷，三年才68块软妹币，美滋滋，还有就是.com 和 .cn 的域名需要备案才能使用，.top的域名可以不用实名认证直接就可以用的。阿里云上选取自己的域名然后用支付宝扫码登录和购买就可以了，非常的方便。</p>
<h2 id="仓库中添加CNAME文件并在文件中填写绑定的域名"><a href="#仓库中添加CNAME文件并在文件中填写绑定的域名" class="headerlink" title="仓库中添加CNAME文件并在文件中填写绑定的域名"></a>仓库中添加CNAME文件并在文件中填写绑定的域名</h2><p>如果是第一次测试的话直接在仓库中建立名为CNAME的文件(文件名大写，且没有后缀)是完全可以的，在CNAME文件中添加刚刚购买的域名，如【homepea.top】，不能包含：【http://】和【www.】，如下图所示：</p>
<p><img src="/images/recording-hexo/5.2.png" alt="CNAME"></p>
<p>然后Github会自动解析的，不过还是自己确认以下最好，在最后的Settings里面，向下翻到【GitHub Pages】即可，找到自己的域名即可。</p>
<p>但是注意，如果上传代码的话CNAME文件会丢失的，因此需要最本地的Hexo文件夹下面的【/source】文件夹下面建一个CNAME文件，内容还是前面购买的域名，这样可以保证每次使用 【 hexo d】指令的时候代码仓CNAME文件还在。这点一定要注意，否则上传了代码可能网站还进不去。</p>
<h2 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h2><p>ping你的<a href="http://github.io" target="_blank" rel="noopener">github.io</a>域名，得到一个IP，如下所示:<br><img src="/images/recording-hexo/5.3.1.png" alt="PING"></p>
<p>登录到阿里云的<a href="https://dns.console.aliyun.com/?spm=a2c4g.11186623.2.12.d00459cbTbdzcz#/dns/domainList" target="_blank" rel="noopener">云解析控制台</a>，如果没有登陆过就添加域名，我是已经添加过了，所以有，然后点击右边的解析设置。<br><img src="/images/recording-hexo/5.3.2.png" alt="ALIYUN"></p>
<p>点击蓝色且显眼的标签“添加记录”，添加两个A记录，用得到的IP，一个主机记录为：“www”，一个为“@”，如图中箭头所示。这样通过<a href="https://homepea.top/" target="_blank" rel="noopener">homepea.top</a>和<a href="https://homepea.top/" target="_blank" rel="noopener">www.homepea.top</a>两种方式就都可以访问自己的网站了。<br><img src="/images/recording-hexo/5.3.3.png" alt="DNS"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个建站的过程花费了接近三天的时间吧，最开始折腾了一点的Coding，到后来用Github的过程，我觉得一路看过来觉得收获还是比较大的，后面如果有哪些有意思的东西，我也会都记录下来。</p>
<p>最后非常感谢我的队友<a href="http://begild.top/" target="_blank" rel="noopener">宝藏</a>，还有看到的一些教程，有掘金的<a href="https://juejin.im/post/5b3ed1d4e51d45194e0b7884#heading-36" target="_blank" rel="noopener">菜包包</a>，知乎的<a href="https://www.zhihu.com/question/31377141/answer/384465402" target="_blank" rel="noopener">SnailClimb</a>，还有最后学习的Markdown书写的<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">高鸿祥</a>，还有参考了很多的教程才有最后的成功，非常感谢。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/404.html</url>
    <content><![CDATA[+layout: false
+---

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>404</title>
    <link rel="alternate" href="/atom.xml" title="Homepea's Blog" type="application/atom+xml">
</head>
    <body>
        <script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回"></script> 
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","hOffset":50,"vOffset":0,"width":200,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>]]></content>
  </entry>
  <entry>
    <title>关于博主</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><h2 id="2014-9-2018-6-本科-中国地质大学-武汉"><a href="#2014-9-2018-6-本科-中国地质大学-武汉" class="headerlink" title="2014.9-2018.6 本科 中国地质大学(武汉)"></a>2014.9-2018.6 本科 中国地质大学(武汉)</h2><p>专业是自动化，学习内容有：自动控制原理、数据结构、电力电子技术、单片机原理及应用、数字电子技术、模拟电子技术、嵌入式系统及应用、电气控制技术及 PLC</p>
<h2 id="2018-6-至今-研究生-中国地质大学-武汉"><a href="#2018-6-至今-研究生-中国地质大学-武汉" class="headerlink" title="2018.6-至今   研究生 中国地质大学(武汉)"></a>2018.6-至今   研究生 中国地质大学(武汉)</h2><p>专业是控制科学与工程，学习内容有：鲁棒与最优控制、机器学习与学习控制、智能优化与最优化方法、人工神经网络及应用、非线性系统分析与控制、模糊控制</p>
<h1 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h1><ul>
<li>熟悉各种计算机操作系统，计算机网络等相关知识，精通嵌入式程序设计和开发</li>
<li>熟练使用嵌入式开发的 Keil、J-Scope 等软件和 PCB 制图的 Altium Designer</li>
<li>熟练使用电路仿真软件 Proteus、Multisim 进行电路仿真</li>
<li>熟练使用Markdown网页编写和微信小程序开发的微信开发者工具</li>
<li>熟练使用 Latex、IgorPro、Coreldraw、AI 和 PhotoShop 等办公软件</li>
</ul>
<h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><ol>
<li>总体而言屌丝一枚吧，喜欢很多新奇的东西会经常去尝试，比如单片机，电路什么的都非常喜欢。以前也结识了很多志同道合的朋友，觉得非常的开心。</li>
<li>想法比较多，想做的事情也非常多，网站建设也在我的想法之内但是却搁置了很久，现在终于有机会来做了。</li>
<li>我是一个很喜欢宅的人，喜欢打游戏、看视频、看电影、听音乐等等一系列不用动身的运动。受这个疫情的影响，我在家待了十来天了，中间就下楼了一次，居然能够忍下来，以前天天打游戏现在也有点觉得不好玩儿了，还是静下心来好好做点事情吧。</li>
<li>感觉我的性格比较随和吧，虽然玩游戏偶尔会化身祖安人，但是现实中非常不喜欢和别人哔哔，就连打球也是经常晚上一个人去篮球场，吹着晚风真的很舒服呀！</li>
<li>不善于表达自己的情绪，因此也失去了一些东西，不知道以后能不能慢慢改变~</li>
</ol>
<h1 id="安利一些自己喜欢的东西吧"><a href="#安利一些自己喜欢的东西吧" class="headerlink" title="安利一些自己喜欢的东西吧"></a>安利一些自己喜欢的东西吧</h1><ul>
<li>歌手：朴树，周杰伦，林俊杰和许嵩等</li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=93% height=86 src="//music.163.com/outchain/player?type=2&id=139392&auto=0&height=66"></iframe>

<ul>
<li><p>电影：周星驰的电影基本都喜欢</p>
</li>
<li><p>B站UP：<a href="https://space.bilibili.com/546195?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">老番茄</a>，<a href="https://space.bilibili.com/382666849/dynamic" target="_blank" rel="noopener">维修厮</a>，<a href="https://www.bilibili.com/video/av82313557" target="_blank" rel="noopener">绵羊料理</a>和<a href="https://space.bilibili.com/390461123/dynamic" target="_blank" rel="noopener">徐大骚</a>等等。</p>
</li>
<li><p>图片：来源B站<a href="https://space.bilibili.com/6823116" target="_blank" rel="noopener">壁纸娘</a>的“Bilibili盛夏”，5K超清！<br><img src="bilibili%E7%9B%9B%E5%A4%8F" alt=""> <img src="https://i0.hdslb.com/bfs/album/3b25bf5db28d008fb341b2955c5b9fd5cde8e738.png"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Homepea的分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Homepea的标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>资源</title>
    <url>/resources/index.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>我个人有一些使用软件上的一些小“洁癖”吧，国内的环境的确是真的非常非常的恶心，各种弹窗和广告数不胜数，还有百度说的“中国人愿意用隐私换取便利”，感觉真的是恶心到我了，这里将我常用的一些软件分享出来，希望能够帮到一些人，至少不受到垃圾广告和弹窗的影响，也为我自己的列一个清单，以后分享页方便。我经常逛的两个论坛是<a href="https://www.ghpym.com/" target="_blank" rel="noopener">果核剥壳</a>和<a href="https://www.52pojie.cn/" target="_blank" rel="noopener">我爱破解</a>这两个，其中大部分资源也都是基于这两个论坛的，但是很多都是用了许久，现在可能不能一一找到相应的出处了，我会尽量找出出处，如果有侵权请联系我一定迅速删除。</p>
<h1 id="日常使用类"><a href="#日常使用类" class="headerlink" title="日常使用类"></a>日常使用类</h1><h2 id="Seer"><a href="#Seer" class="headerlink" title="Seer"></a>Seer</h2><p><a href="https://pan.baidu.com/s/1XDqQ9kg9xCT2OOJSQCV9nw" target="_blank" rel="noopener">Seer</a>可以实现Windown上像Mac一样的空格预览，可以预览非常多的文件，尤其时Gif，这个需求时真的很大，而且markdown文件也可以时时预览，用起来真的非常舒服。</p>
<h1 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h1><p><a href="https://pan.baidu.com/s/1j533U7llMe3yrsFSC7c5MA" target="_blank" rel="noopener">Snipaste</a>妥妥的生产力工具，我觉得时win系统最好用的截图工具了，还能贴图，自从用了这个我就放弃了QQ、微信和win自带的截图软件了，真的巨好用。</p>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>浏览器我一直用的<a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a>，相信大家也知道国内的浏览器基本都是根据谷歌的开源计划改的吧，当然可能改的很好，不过我看了我上面介绍乐那么多绿色版的东西，我觉得还是原版的好。不多说了，打开链接直接下载即可。</p>
<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>音乐播放器，我一直使用的<a href="https://pan.baidu.com/s/18gson3K_KicLeowQtPTAxg" target="_blank" rel="noopener">网易云</a>，虽然乐库越来越少，但是真的还算良心，我也是一直在使用的，上面分享的是绿色版，其实就是我以前自己安装的老版本，这个左侧没有Look直播，头像没有开会员的提醒，我设置不自动更新，就这样一直用着吧。</p>
<h2 id="MpvPlayer"><a href="#MpvPlayer" class="headerlink" title="MpvPlayer"></a>MpvPlayer</h2><p>视频播放器我用的<a href="https://pan.baidu.com/s/1QSy_Yne2REjEahbEAV_OGg" target="_blank" rel="noopener">MpvPlayer</a>，这样说吧，应该是我见过最好用的一个播放器了，比Plot，foobar这种好多了，真心简洁但是功能一个不差，倍速慢速，换音源，还能逐帧播放，关键还开源，我觉得暂时没有比他更好的本地播放器了。其他的网站上面的我都是用的浏览器在线播放，因为有插件能去广告，非常方便。</p>
<h2 id="IOBUninstall"><a href="#IOBUninstall" class="headerlink" title="IOBUninstall"></a>IOBUninstall</h2><p><a href="https://pan.baidu.com/s/1jBOqG2ltNcECuYPS1rWkSg" target="_blank" rel="noopener">IOBUninstall</a>我觉得良心制作，基础功能足矣，这个是绿色版，直接安装的，最大的好处是可以卸载win10自带的uwp，非常给力，而且卸载的足够干净。</p>
<h2 id="WEI-PE"><a href="#WEI-PE" class="headerlink" title="WEI_PE"></a>WEI_PE</h2><p>装系统肯定是用<a href="https://pan.baidu.com/s/1T5UzjWey_MIbu2b_znaG9w" target="_blank" rel="noopener">WEI_PE</a>，国内的环境是真的恶心，用什么大白菜，U启动神的的基本一大推捆绑，好美其名曰推荐，这个PE制作是完全放心的，但是我现在好像已经搜不到观望了，就把以前下载的东西放出来，这个东西用过了就知道什么叫做清爽。</p>
<h1 id="文本编辑类"><a href="#文本编辑类" class="headerlink" title="文本编辑类"></a>文本编辑类</h1><h2 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h2><p>我用的最多的一个文本编辑器了，特点就是快，因为他的本质就是一个文本编辑器，但是相应的插件支持非常多，支持的文件格式非常多，不管是做编程还是写文本都是非常的好用。至少我现在的tet文件，写Latex，还是Markdown写现在的网页都是用的它，配合其他的插件真的很好用，效率也很高，最先安利的一个了。网上看了很多资源，最后还是选择了果核的软件，我保存了其他人收集的结果<a href="https://pan.baidu.com/s/16944rScjYeHwrJvyO2TyiA" target="_blank" rel="noopener">链接</a>。</p>
<h2 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h2><p><a href="https://pan.baidu.com/s/1Gdn_E2dxnUxIS_PN95b9iA" target="_blank" rel="noopener">UltraEdit</a>应该是一个老牌软件了，一些资深的程序员都在用这个，它查看二进制文件或者用二进制查看文件非常的优秀，这个是Sublime和VSCode不能比的，本人电脑也保留了一个，毕竟绿色版解压就能用，也不碍事。</p>
<h1 id="论文撰写类"><a href="#论文撰写类" class="headerlink" title="论文撰写类"></a>论文撰写类</h1><h2 id="MikTex"><a href="#MikTex" class="headerlink" title="MikTex"></a>MikTex</h2><p>论文写作最麻烦的就是格式问题，这个使用Latex可以很好的解决，而且现在各大杂志都有自己的Latex模板，直接使用即可，那么编辑就成了一个很大的问题了。刚刚过去的时候很多同学推荐CTEX这个软件，一看4G的大小，而且界面非常丑，而且也没有代码高亮啥的，更关键的是找error让我觉得非常难受，因此网上看了很多方法，让我看到了MikTex，其实还有比如TeXlive等等，都是差不多的，因此我是使用的这个<a href="https://pan.baidu.com/s/1_nAJxLTqCaPZn9F9bbzSXQ" target="_blank" rel="noopener">MikTex</a>，安装的时候最好选取“自动下载文章确实的包”，因为这个软件毕竟是Basic的，很多的包还是需要后期安装的，安装完了之后页可以直接编辑tex文件，这个软件也是有编辑器和PDF阅读器的，但是也都是基本的东西，用起来还行吧，但是还是要配合<a href="(https://pan.baidu.com/s/16944rScjYeHwrJvyO2TyiA)">Sublime</a>更好的。</p>
<h2 id="PDF查看"><a href="#PDF查看" class="headerlink" title="PDF查看"></a>PDF查看</h2><p>说实话，国内的PDF阅读器看了很久，没有一个我觉得是正常的，金山、福析和闪电等等阅读器是真的难用，还有那个知网出的那个什么可以读CAJ格式那两个垃圾阅读器，真的慢死了，广告那么大的板块，真的忍不了，其实真正能用的可能也就Adobe的了，后面有推荐，不过论文撰写方面肯定是<a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">SumatraPDF</a>，占用体积小，安装完了10M，速度是真的快，而且能够双击连接到Sublime写的文章的对应行上面去，修改论文非常方便，而且他的缩放是很合适，用过的绝对会觉得非常爽。</p>
<p>除了PDF查看，偶尔也需要对PDF文件作一些小小的更改，特别是有些时候别人发过来的PDF文件，Adobe的阅读器当然可以，但是比较大门后面有介绍，这里介绍<a href="https://pan.baidu.com/s/1l7pc79MVNZEA96ofPMg7WA" target="_blank" rel="noopener">Xchange PDF</a>，也是轻量级的，我一般放在电脑里面吃灰，但是偶尔有时候会非常有用哦。</p>
<h1 id="资源下载类"><a href="#资源下载类" class="headerlink" title="资源下载类"></a>资源下载类</h1><h2 id="迅雷简化版"><a href="#迅雷简化版" class="headerlink" title="迅雷简化版"></a>迅雷简化版</h2><p>迅雷的做法大家可以去搜搜，种子协议在国内快被他们搞垮了，因此破解版的也层出不穷。如果没错的话来源是我爱破解，但是具体的链接忘了，这个没有任何弹窗，而且在win10_1809可以正常使用，破解了VIP链接但是没有任何的显示，也无需登录，是我用的最久的一个版本了，<a href="https://pan.baidu.com/s/10ToTFaETm3xkBhHv671YRA" target="_blank" rel="noopener">绿色版</a>的，解压直接用即可，快捷方式在D盘的，大家根据快捷方式自己找文件目录吧。</p>
<h2 id="IDM"><a href="#IDM" class="headerlink" title="IDM"></a>IDM</h2><p>IDM应该是我见过的最好用的下载器了，关键是其浏览器插件非常好用，网站视频啥的基本都能下载，而且多线程技术让他下载速度非常快，特别是国外的资源，比如会议论文模板，深度学习训练集等等，唯一的缺点是不支持种子文件下载。这里直接给到果核的<a href="https://www.ghpym.com/pcidm.html" target="_blank" rel="noopener">IDM链接</a>自行下载吧。</p>
<h2 id="PanDownload"><a href="#PanDownload" class="headerlink" title="PanDownload"></a>PanDownload</h2><p>百度云的工具，百度云大家都知道，不多介绍，这个软件有一个很大的优点是搜集了一些番剧的网站，应该是爬的，因此会随着其他网站更新而更新，非常方便，缺点是现在旧版本是不能用，直接上<a href="https://pandownload.com/" target="_blank" rel="noopener">官网</a>。</p>
<h1 id="编程开发类"><a href="#编程开发类" class="headerlink" title="编程开发类"></a>编程开发类</h1><h2 id="MingW64"><a href="#MingW64" class="headerlink" title="MingW64"></a>MingW64</h2><p>学过C语言的应该可能都知道C语言是可以通过命令行一步一步编译的，MingW64就不用说了，这里给出<a href="https://pan.baidu.com/s/1H5E3-etgW33w04zCHOqyug" target="_blank" rel="noopener">下载链接</a>，解压即用，注意要添加环境变量。这个不建议新手使用，一般也是结合Sublime或者VSCode用，因为有图形化界面。</p>
<h2 id="Codebock"><a href="#Codebock" class="headerlink" title="Codebock"></a>Codebock</h2><p><a href="https://pan.baidu.com/s/1QAmdPykqFiS77O63NY3nxw" target="_blank" rel="noopener">CodeBlock</a>这个软件是大一学习C语言老师推荐的，也是用了很久，集成了很多环境，不需要任何配置上手就能用，非常方便，界面十分简洁，但是我觉得不够友好吧，很多区域不能个性化定制，可能是我自己没找到方法，因此后面用的不多了，总体而言非常不错的。</p>
<h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p>这个是微软开发的开源免费软件，一路逆袭，现在的势头也很猛，对于编程而言非常合适，比如C、C++、PyThon等等，都是非常的合适，中文支持，而且支持迁移原来的编辑器的风格，都是轻量级的软件，值得推荐。由于他现在还是不断更新，我直接更上<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">官网</a>，但是说到底，它的主要功能还是编辑器，因此没有其他的编译链，如果编写C和C++语言需要MingW64，编写Python需要对应版本的Python安装。</p>
<h2 id="Keil"><a href="#Keil" class="headerlink" title="Keil"></a>Keil</h2><p>玩过单片机的应该都知道Keil吧，我讲官网的打包了放在这里，因为官网下载要注册，然后就会一直给你邮箱里面发广告，很麻烦。<a href="https://pan.baidu.com/s/1mpuSBt2lebtfdS4DXgrCBQ" target="_blank" rel="noopener">内容</a>，这里Keil4和Keil5都有，一个是51系列的，另一个是ARM系列的，我找了STM32和K60的两个系列的包，都是可以直接使用的。</p>
<h2 id="SourceInsight"><a href="#SourceInsight" class="headerlink" title="SourceInsight"></a>SourceInsight</h2><p><a href="https://pan.baidu.com/s/15RvsNKFLzu-eahbCiKvsJw" target="_blank" rel="noopener">SourceInsight</a>是查看和修改代码的好工具，特别是查看Linux内核时，各种复杂的引用还有非常多的头文件，用SourceInsight绝对可以事半功倍。</p>
<h1 id="Adobe系列"><a href="#Adobe系列" class="headerlink" title="Adobe系列"></a>Adobe系列</h1><p>来源：<a href="https://weibo.com/vposy?is_hot=1" target="_blank" rel="noopener">嬴政天下</a>。这里仅作分享，因为是专业版的软件，懂的人自然懂。我这里保留的大都是<a href="https://pan.baidu.com/s/1ouIM91BDU4OSibIxCwhjSQ" target="_blank" rel="noopener">2020版本</a>，这个版本对平台要求比较高，不支持win7的，一定要注意。还有一些其他版本的在后面做一些说明。</p>
<p><a href="https://pan.baidu.com/s/1JK6ePfzN21ZsRZJzEJITtQ" target="_blank" rel="noopener">PhotoShopCS6</a>这个版本是我本科室友分享的，一直用到了现在，功能齐全而且非常快，支持win7，直接解压打开文件夹中的【!)PhotoShopCS6x64Portable.exe】安装即可，但是注意一定要关闭杀毒软件！！！</p>
<p><a href="https://pan.baidu.com/s/1Rwodbuz-hpwlVQlZLjjP8A" target="_blank" rel="noopener">AcrobatProDC</a>用的很久，2020版本的我前面看到的是没有PDF阅读器的，我也一直用的这个，安装完了就能直接使用，非常好用。自带虚拟打印机，虽然软件很大，但是打开速度很快，Adobe自带的文字识别也是好用到不行。</p>
<h1 id="链接说明"><a href="#链接说明" class="headerlink" title="链接说明"></a>链接说明</h1><p>我虽然不喜欢百度云，但是说实话已经用了很久了，上面有很多的资源，所示还是分享的百度云链接，我分享的密码都是【2333】。还有就是只是软件的推荐，没有任何的教程，网上都是一搜一大把的，也非常仔细，如果有什么没有弄好或者觉得不清楚的欢迎评论或者给我发邮件说明哦~</p>
]]></content>
  </entry>
  <entry>
    <title>收藏</title>
    <url>/favorites/index.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>我这个人有点无聊，一般每个学习主用的电脑都会重新装一次系统，但是我的软件基本都是绿色版，因此一般我半个小时就可以基本恢复好，但是浏览器上面的数千每次回复比较慢，这个我觉得比较烦，而且有时候梯子不好用了，因此在这里将我的数千同步一下，也做一个分享，希望上面的资源能够帮到大家。</p>
<h1 id="主页类"><a href="#主页类" class="headerlink" title="主页类"></a>主页类</h1><h2 id="Google-淘宝-谷歌翻译-Bilibili"><a href="#Google-淘宝-谷歌翻译-Bilibili" class="headerlink" title="Google 淘宝 谷歌翻译 Bilibili"></a><a href="https://www.google.com" target="_blank" rel="noopener">Google</a> <a href="https://www.taobao.com" target="_blank" rel="noopener">淘宝</a> <a href="https://translate.google.com/?hl=zh-CN" target="_blank" rel="noopener">谷歌翻译</a> <a href="https://www.bilibili.com/" target="_blank" rel="noopener">Bilibili</a></h2><h1 id="CUG"><a href="#CUG" class="headerlink" title="CUG"></a>CUG</h1><DT><A HREF="http://192.168.167.14/" target="_blank" rel="noopener" >CUG_WiFi</A>
<DT><A HREF="http://epo.cug.edu.cn/" target="_blank" rel="noopener" >研究生信息管理中心</A>
<DT><A HREF="http://10.16.0.113/inde" target="_blank" rel="noopener">CUG自动化学院</A>
<DT><A HREF="http://pay.cug.edu.cn/xysf/frame_container.aspx" target="_blank" rel="noopener" >CUG支付平台</A>
<DT><A HREF="http://mail.cug.edu.cn/" target="_blank" rel="noopener" >CUG_Mail</A>
<DT><A HREF="http://acm.cug.edu.cn/" target="_blank" rel="noopener" >ACM</A>
<DT><A HREF="http://10.16.0.113/index" target="_blank" rel="noopener" >先进控制技术实验室</A>
<DT><A HREF="http://202.114.200.86/open/Lesson_TestView.aspx" target="_blank" rel="noopener" >学期考试信息查询</A>
<DT><A HREF="http://10.16.0.113/admin" target="_blank" rel="noopener" >实验室后台登陆</A>
<DT><A HREF="https://www.google.com/earth/studio/" target="_blank" rel="noopener" >Google Earth Studio</A>
<DT><A HREF="http://zcgl.cug.edu.cn/" target="_blank" rel="noopener" >中国地质大学资产综合管理系统</A>
<DT><A HREF="http://cw.cug.edu.cn/" target="_blank" rel="noopener" >中国地质大学(武汉)财务处</A>
<DT><A HREF="https://github.com/wandou911/ssr" target="_blank" rel="noopener" >GitHub - wandou911/ssr: ssr免费节点</A>
<DT><A HREF="https://lncn.org/" target="_blank" rel="noopener" >免费节点 - lncn.org</A>
<DT><A HREF="https://www.52pojie.cn/" target="_blank" rel="noopener" >吾爱破解 </A>
<DT><A HREF="https://www.iconfont.cn/" target="_blank" rel="noopener" >Iconfont-阿里巴巴矢量图标库</A>
<DT><A HREF="https://leetcode-cn.com/explore/" target="_blank" rel="noopener" >LeetCode</A>
<DT><A HREF="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener" >(5) 题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</A>
<DT><A HREF="http://www.soopat.com/" target="_blank" rel="noopener" >SooPAT 专利搜索</A>
<DT><A HREF="http://www.360doc.com/content/18/1210/23/25934206_800797613.shtml" target="_blank" rel="noopener" >常用乐高零件名称及命名规则</A>
<DT><A HREF="https://study.163.com/course/courseLearn.htm" target="_blank" rel="noopener">   网易云课堂</A>      
<DT><A HREF="http://begild.top/" target="_blank" rel="noopener" >BeGild Working - BeGild&#39;s Blog</A>
<DT><A HREF="http://homepea.top/" target="_blank" rel="noopener" >杜晨的博客</A>
<DT><A HREF="https://github.com/Homepea7/Homepea7.github.io" target="_blank" rel="noopener" >Homepea7/Homepea7.github.io</A>


<h1 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h1><DT><A HREF="https://www.ieee.org/index.html" target="_blank" rel="noopener" >IEEE</A>
<DT><A HREF="https://scholar.google.com/schhp?hl=zh-cn" target="_blank" rel="noopener" >Learning</A>
<DT><A HREF="http://www.sciencedirect.com/" target="_blank" rel="noopener" >SCI</A>
<DT><A HREF="https://scholar.google.com.hk/?hl=zh-CN" target="_blank" rel="noopener" >Google 学术搜索</A>
<DT><A HREF="http://www.cnki.net/" target="_blank" rel="noopener" >知网</A>
<DT><A HREF="http://new.oversea.cnki.net/index/" target="_blank" rel="noopener" >CNKI</A>
<DT><A HREF="http://www.lib.cug.edu.cn/zy/commondb.htm" target="_blank" rel="noopener" >常用数据库</A>
<DT><A HREF="http://202.114.202.207/reader/redr_info.php" target="_blank" rel="noopener" >中国地质大学图书馆v5.6书目检索系统</A>
<DT><A HREF="http://www.lib.cug.edu.cn/" target="_blank" rel="noopener" >中国地质大学图书馆--首页</A>
<DT><A HREF="http://202.114.202.219/reslist" target="_blank" rel="noopener" >资源列表</A>
<DT><A HREF="http://www.lib.cug.edu.cn/pageinfo?cid=246" target="_blank" rel="noopener" >校外访问</A>
<DT><A HREF="http://www.sci-hub.tw/" target="_blank" rel="noopener" >Sci-Hub: removing barriers in the way of science</A>
<DT><A HREF="http://www.sipo.gov.cn/" target="_blank" rel="noopener" >国家知识产权局</A>
<DT><A HREF="https://www.uspto.gov/" target="_blank" rel="noopener" >United States Patent and Trademark Office</A>
<DT><A HREF="http://c.oldg.wanfangdata.com.cn/PatentIndex.aspx" target="_blank" rel="noopener" >sci-hub最新可用网址大全</A>
<DT><A HREF="https://blog.csdn.net/csdn_moming/article/details/50585021" target="_blank" rel="noopener" >ICM——LaTeX排版</A>
<DT><A HREF="https://www.engineeringvillage.com/search/quick.url" target="_blank" rel="noopener" >Engineering Village </A>
<DT><A HREF="http://apps.webofknowledge.com/WOS_GeneralSearch_input.do?product=WOS&search_mode=GeneralSearch&SID=6F33DOq6xsv2fbHvWSG&preferencesSaved=" target="_blank" rel="noopener" >Web of Science</A>                



<h1 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h1><DT><A HREF="http://www.tensorfly.cn/tfdoc/get_started/introduction.html" target="_blank" rel="noopener" >介绍 | TensorFlow 官方文档中文版</A>
<DT><A HREF="https://space.bilibili.com/209599371/#/channel/detail?cid=23541" target="_blank" rel="noopener" >MXNet_Gluon的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili</A>
<DT><A HREF="http://www.tensorfly.cn/tfdoc/tutorials/overview.html" target="_blank" rel="noopener" >总览 | TensorFlow 官方文档中文版</A>
<DT><A HREF="https://mp.weixin.qq.com/s?spm=a2c4e.11153940.blogcont583670.11.62e75de5LJmWQm&__biz=MzAxMjMwODMyMQ==&mid=2456336157&idx=1&sn=109b62b0b2f153f2ae1d7416f90cdc13&chksm=8c2fcd13bb5844051b2d9834f4ad6371e654d8aa04fc09ef9193b0c720a0524e5385347ff46c&scene=21#wechat_redirect" target="_blank" rel="noopener" >磐创AI</A>
<DT><A HREF="https://zhuanlan.zhihu.com/p/27180274" target="_blank" rel="noopener" >深度学习资源汇总</A>
<DT><A HREF="https://www.bilibili.com/video/av20542427?from=search&seid=10483055109705593256" target="_blank" rel="noopener" >深度学习框架Tensorflow学习与应用_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener" >Tensorflow 教程系列 | 莫烦Python</A>
<DT><A HREF="https://www.jianshu.com/p/2ea7a0632239" target="_blank" rel="noopener" >五分钟带你入门TensorFlow - 简书</A>
<DT><A HREF="https://www.tensorflow.org/tutorials/" target="_blank" rel="noopener" >TensorFlow</A>
<DT><A HREF="https://www.bilibili.com/video/av20542427/?p=8" target="_blank" rel="noopener" >深度学习框架Tensorflow学习与应用_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://blog.csdn.net/zj360202/article/details/70259999" target="_blank" rel="noopener" >【Tensorflow】tf.argmax函数 - CSDN博客</A>
<DT><A HREF="https://www.bilibili.com/video/av20542427/?p=11" target="_blank" rel="noopener" >深度学习框架Tensorflow学习与应用_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener" >Tensorflow 教程系列 | 莫烦Python</A>
<DT><A HREF="http://www.runoob.com/w3cnote/python-spider-intro.html" target="_blank" rel="noopener" >Python 爬虫介绍 | 菜鸟教程</A>
<DT><A HREF="https://zhuanlan.zhihu.com/p/21479334" target="_blank" rel="noopener" >如何学习Python爬虫[入门篇]？</A>
<DT><A HREF="https://developers.google.com/machine-learning/crash-course/ml-intro" target="_blank" rel="noopener" >机器学习简介 (Introduction to Machine Learning)  |  机器学习速成课程  |  Google Developers</A>
<DT><A HREF="http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/" target="_blank" rel="noopener" >从0开始学习 GitHub 系列之「初识 GitHub」 - stormzhang</A>
<DT><A HREF="https://guides.github.com/activities/hello-world/" target="_blank" rel="noopener" >Hello World · GitHub Guides</A>
<DT><A HREF="https://github.com/orgs/KavinHomepea/people?query=role%3Aowner" target="_blank" rel="noopener" >People · KavinHomepea</A>
<DT><A HREF="https://github.com/michaelliao" target="_blank" rel="noopener" >michaelliao (Michael Liao) · GitHub</A>
<DT><A HREF="https://github.com/join/customize" target="_blank" rel="noopener" >GitHub · Where software is built</A>
<DT><A HREF="https://github.com/cheneyveron/clover-x79-e5-2670-gtx650" target="_blank" rel="noopener" >GitHub - cheneyveron/clover-x79-e5-2670-gtx650: Hackintosh clover perfect for High Sierra / Mojave / Catalina</A>
<DT><A HREF="https://ubuntu-mate.org/download/" target="_blank" rel="noopener" >Download | Ubuntu MATE</A>


<h1 id="电子制作"><a href="#电子制作" class="headerlink" title="电子制作"></a>电子制作</h1><DT><A HREF="http://www.openedv.com/" target="_blank" rel="noopener" >原子</A>
<DT><A HREF="https://github.com/MHEtLive/ESP32-MINI-KIT/issues/4" target="_blank" rel="noopener" >Internal LED · Issue #4 · MHEtLive/ESP32-MINI-KIT · GitHub</A>
<DT><A HREF="http://bbs.ai-thinker.com/forum.php" target="_blank" rel="noopener" >论坛 - 安信可科技</A>
<DT><A HREF="http://www.datasheet5.com/" target="_blank" rel="noopener" >DateSheet5</A>
<DT><A HREF="http://www.ti.com.cn/" target="_blank" rel="noopener" >TI</A>
<DT><A HREF="https://grabcad.com/library" target="_blank" rel="noopener" >Grabcad</A>
<DT><A HREF="http://www.3dcontentcentral.cn/default.aspx" target="_blank" rel="noopener" >3D ContentCentral</A>
<DT><A HREF="https://tool.lu/" target="_blank" rel="noopener" >在线工具</A>
<DT><A HREF="http://bbs.elecfans.com/jishu_949360_1_1.html" target="_blank" rel="noopener" >ESP32博客</A>
<DT><A HREF="https://github.com/MHEtLive/ESP32-MINI-KIT/tree/master/Shield%20libraries" target="_blank" rel="noopener" >ESP32-MINI-KIT/Shield libraries at master · MHEtLive/ESP32-MINI-KIT · GitHub</A>
<DT><A HREF="https://www.jianshu.com/p/f7ace175e643" target="_blank" rel="noopener" >【ESP32】在Windows下搭建ESP32开发环境 - 简书</A>
<DT><A HREF="https://www.cnblogs.com/hongwans/p/7772833.html" target="_blank" rel="noopener" >野路子学习esp32(三) 导入ESP32_IDF,编译案例Hello_World @a.宏万 - 宏万工作室 - 博客园</A>
<DT><A HREF="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener" ADD_DATE="1543286023">Support for external RAM — ESP-IDF Programming Guide v3.3-dev-236-gfa59b1b documentation</A>
<DT><A HREF="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/get-started/linux-setup.html" target="_blank" rel="noopener" ADD_DATE="1546526251">Linux 平台工具链的标准设置 — ESP-IDF 编程指南 v3.3-beta1-169-g3c94b6e 文档</A>
<DT><A HREF="http://fengmeitech.club/category/%E9%9D%92%E6%9F%9Azero/" target="_blank" rel="noopener" ADD_DATE="1561374927">青柚ZERO – 风媒实验室</A>
<DT><A HREF="https://book.openmv.cc/python-background.html" target="_blank" rel="noopener" >Python背景知识 · OpenMV中文入门教程</A>
<DT><A HREF="https://book.openmv.cc/MCU/pyb.html" target="_blank" rel="noopener" >pyb各种外设 · OpenMV中文入门教程</A>
<DT><A HREF="https://book.openmv.cc/quick-starter.html" target="_blank" rel="noopener" >10分钟快速上手 · OpenMV中文入门教程</A>
<DT><A HREF="https://www.alldatasheetcn.com/" target="_blank" rel="noopener" >WWW.ALLDATASHEETCN.COM - IC搜索-提供Datasheet, IC数据表, datasheet资料表, ic资料表, 电子元器件手册, 电子元件手册 等 资料下载中心, 为电子元件和半导体等的供应商。</A>
<DT><A HREF="https://www.bilibili.com/video/av37951162/?spm_id_from=333.788.videocard.5" target="_blank" rel="noopener" >【黑苹果教程】AMD锐龙平台完美吃上黑苹果，无需安装任何驱动！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://www.coursera.org/" target="_blank" rel="noopener" >Coursera</A>

<h1 id="效率资源"><a href="#效率资源" class="headerlink" title="效率资源"></a>效率资源</h1><DT><A HREF="https://www.facebook.com/home.php?ref=wizard" target="_blank" rel="noopener" >FB</A>
<DT><A HREF="https://www.bilibili.com/video/av19321436?p=2" target="_blank" rel="noopener" >SmallPinkPig</A>
<DT><A HREF="https://www.bilibili.com/video/av19321436/?p=15" target="_blank" rel="noopener" >【英文原版1080P】小猪佩奇 第一季第二季全集 （英文字幕）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://study.163.com/course/courseMain.htm?courseId=1003681015" target="_blank" rel="noopener" >TED演讲集：心理 - 网易云课堂</A>
<DT><A HREF="https://www.bilibili.com/video/av16404880/?p=6" target="_blank" rel="noopener" >自由泳入门（第二版）教学视频_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</A>
<DT><A HREF="https://vectormagic.com/" target="_blank" rel="noopener" >Vector Magic: Convert JPG, PNG images to SVG, EPS, AI vectors</A>
<DT><A HREF="https://wallpaperscraft.com/catalog/3d/2560x1080" target="_blank" rel="noopener" >3d wallpapers dual wide 1080p, desktop backgrounds hd, pictures and images</A>
<DT><A HREF="http://www.1ppt.com/article/52542.html#xiazai" target="_blank" rel="noopener" >天安门华表背景的社会主义核心价值观PPT模板 - 第一PPT</A>
<DT><A HREF="https://education.lego.com/zh-cn" target="_blank" rel="noopener" >乐高教育</A>
<DT><A HREF="https://www.lego.com/zh-cn" target="_blank" rel="noopener" >Home | LEGO.com CN</A>
<DT><A HREF="https://blog.csdn.net/constantin_/article/details/79575638" target="_blank" rel="noopener" >C语言指针详解(经典,非常详细) - constantin_的博客 - CSDN博客</A>
<DT><A HREF="http://www.semia.com/" target="_blank" rel="noopener" >西觅亚官方网站–西觅亚科技,乐高机器人,乐高教育, 幼儿,机械,能源全系列教育产品,教材和培训semia官方网站</A>
<DT><A HREF="https://xjh.haitou.cc/wh" target="_blank" rel="noopener" >海投</A>
<DT><A HREF="https://mp.weixin.qq.com/wxopen/initprofile?action=home&lang=zh_CN&token=445497167" target="_blank" rel="noopener" ADD_DATE="1534731366">微信公众平台</A>
<DT><A HREF="https://getitfree.cn/" target="_blank" rel="noopener" >正版中国 | 正版软件限时免费</A>
<DT><A HREF="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000#0" target="_blank" rel="noopener" >使用元类 - 廖雪峰的官方网站</A>
<DT><A HREF="https://gallerix.asia/" target="_blank" rel="noopener" >绘画、 艺术家、 图片。</A>
<DT><A HREF="http://www.ypppt.com/" target="_blank" rel="noopener" >PPT模板下载_免费PPT模板下载_精美免费PPT模板下载 - 优品PPT</A>
<DT><A HREF="http://git.gupaoedu.com/ldqk/soft" target="_blank" rel="noopener" >懒得勤快 / soft · GitLab</A>
<DT><A HREF="https://www.lulinux.com/archives/1319" target="_blank" rel="noopener" ></A>
<DT><A HREF="http://www.lanzou.com/u" target="_blank" rel="noopener" >蓝奏云-控制台</A>
<DT><A HREF="http://www.1ppt.com/" target="_blank" rel="noopener" >PPT模板_PPT模板下载_幻灯片模板_PPT模版免费下载 -【第一PPT】</A>
<DT><A HREF="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener" >OfficePLUS，微软Office官方在线模板网站！</A>
<DT><A HREF="https://slidemodel.com/" target="_blank" rel="noopener" >Professional PowerPoint Templates &amp; Slides - SlideModel.com</A>
<DT><A HREF="http://www.docer.com/" target="_blank" rel="noopener" >PPT模板-简历模板-图片素材-Docer稻壳儿分享有价值的文档、视频和模板资源-Docer稻壳儿</A>
<DT><A HREF="https://www.sqlsec.com/2018/08/clover.html" target="_blank" rel="noopener" >B站黑苹果安装教程 | 国光</A>
<DT><A HREF="https://www.flighty.cn/index_1.html" target="_blank" rel="noopener" >轻狂志 - 少轻狂分享优质软件资源！</A>
<DT><A HREF="http://www.icxbk.com/article/detail/434.html" target="_blank" rel="noopener" >Adafruit Circuit Express可穿戴开发板之初体验-电子芯吧客（www.icxbk.com）</A>
<DT><A HREF="https://www.sqlsec.com/friends/" target="_blank" rel="noopener" >友情链接 | 国光</A>
<DT><A HREF="https://github.com/daliansky/Hackintosh" target="_blank" rel="noopener" >daliansky/Hackintosh: Hackintosh long-term maintenance model EFI and installation tutorial</A>
<DT><A HREF="https://blog.daliansky.net/Mojave-Hardware-Support-List.html" target="_blank" rel="noopener" >Mojave硬件支持列表（持续更新中） | 黑果小兵的部落阁</A>
<DT><A HREF="https://h.bilibili.com/2464388" target="_blank" rel="noopener" >哔哩哔哩相簿</A>
<DT><A HREF="http://www.dayanzai.me/" target="_blank" rel="noopener" >大眼仔旭 - 爱软件 爱汉化 爱分享 博客型软件首页</A>
<DT><A HREF="https://www.itpwd.com/efi/" target="_blank" rel="noopener" >黑果引导_IT密码_You are the reason why I became stronger. But still, you are my weakness.</A>
<DT><A HREF="https://zhuanlan.zhihu.com/p/75718363" target="_blank" rel="noopener" >黑苹果配置选购指南之ITX篇--2019年7月 - 知乎</A>
<DT><A HREF="https://icyleaf.com/2019/03/asrock-z390-gaming-itx-install-hackintosh-tutorial/" target="_blank" rel="noopener" >华擎 Z390 Gaming ITX 黑苹果安装教程 · icyleaf</A>
<DT><A HREF="https://www.52pojie.cn/thread-1064680-1-1.html" target="_blank" rel="noopener" >CSOL2（反恐精英ol2）一键端（汉化加完美教程） - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn</A>
<DT><A HREF="https://www.ghpym.com/win10mac.html" target="_blank" rel="noopener" >使用Win10，打造属于你的黑苹果 - 果核剥壳</A>
<DT><A HREF="https://wqbook.wqxuetang.com/" target="_blank" rel="noopener" >文泉书局</A>
<DT><A HREF="http://sc.chinaz.com/" target="_blank" rel="noopener" >站长素材-分享综合设计素材的平台</A>
<DT><A HREF="https://www.runoob.com/" target="_blank" rel="noopener" >菜鸟教程 - 学的不仅是技术，更是梦想！</A>
<DT><A HREF="https://www.52pojie.cn/thread-1079337-1-1.html" target="_blank" rel="noopener" >免Root使用ADB命令_停用手机系统应用 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn</A>
<DT><A HREF="http://fontawesome.dashgame.com/" target="_blank" rel="noopener" >Font Awesome，一套绝佳的图标字体库和CSS框架</A>
<DT><A HREF="https://pan.baidu.com/disk/home#/all?path=%2F&vmode=list" target="_blank" rel="noopener" >百度网盘-全部文件</A>


<h1 id="电影资源"><a href="#电影资源" class="headerlink" title="电影资源"></a>电影资源</h1><DT><A HREF="http://www.dytt8.net/" target="_blank" rel="noopener" >电影天堂_免费电影_迅雷电影下载</A>
<DT><A HREF="http://bddn.cn/zb.htm" target="_blank" rel="noopener" >全国电视直播---bddn.cn</A>
<DT><A HREF="http://www.5ifxw.com/vipshipin/" target="_blank" rel="noopener" >爱奇艺vip 乐视 腾讯优酷vip视频在线解析</A>
<DT><A HREF="http://www.baocaibt.org/" target="_blank" rel="noopener" >BT手撕包菜 - 收录最全最快的磁力链接搜索引擎</A>
<DT><A HREF="http://www.5ifxw.com/zhuangbi/" target="_blank" rel="noopener" >斗图大会-在线制作表情包生成器-无形装逼最为致命！</A>
<DT><A HREF="http://www.5ifxw.com/fuli/" target="_blank" rel="noopener" >我爱分享网福利平台</A>
<DT><A HREF="http://www.dyxia.com/" target="_blank" rel="noopener" >全集网_全集电影网_迅雷电影下载_高清电影下载_BT种子电影下载</A>
<DT><A HREF="http://www.aicili.pw/" target="_blank" rel="noopener" >电影天堂 | 顺利进入第六年</A>
<DT><A HREF="http://www.soyunpan.com/" target="_blank" rel="noopener" ADD_DATE="1530155087">百度云网盘资源搜索引擎_搜云盘!</A>
<DT><A HREF="http://www.panduoduo.net/" target="_blank" rel="noopener" ADD_DATE="1530155241">盘多多-百度云盘-百度云搜索-百度云盘资源搜索-百度网盘搜索引擎-微盘,新浪微盘-网盘搜索_盘多多</A>
<DT><A HREF="https://www.torrentkitty.tv/search/" target="_blank" rel="noopener" ADD_DATE="1533446089">Torrent Kitty - Free Torrent To Magnet Link Conversion Service</A>
<DT><A HREF="https://btdigg.cc/" target="_blank" rel="noopener" >BTDigg - p2p种子搜索器，BT种子搜索神器，磁力链接搜索网站</A>
<DT><A HREF="https://www.btdalu.com/" target="_blank" rel="noopener" >bt大陆 - 磁力链接搜索,bt种子搜索,资源电影下载</A>
<DT><A HREF="http://www.mvcat.com/" target="_blank" rel="noopener" >电影推荐 · MVCAT</A>
<DT><A HREF="http://v.wenkuwenku.com/" target="_blank" rel="noopener" >VIP视频网站解析 一键解析爱奇艺,优酷,腾讯,乐视,芒果等各大视频网站的VIP视频-去广告播放</A>
<DT><A HREF="http://www.youzhidy.com/" target="_blank" rel="noopener" >优质电影网_1080P高清电影下载_3D蓝光原盘高清电影下载</A>
<DT><A HREF="http://www.verycd.com/" target="_blank" rel="noopener" >VeryCD电驴大全 - 不听指点，多绕弯弯</A>
<DT><A HREF="http://www.hdwan.net/page/3" target="_blank" rel="noopener" >海盗湾中文网 | 最新720P、1080P高清电影种子下载网站,海盗湾。 - 第3页</A>
<DT><A HREF="http://www.bttwo.com/" target="_blank" rel="noopener" >两个BT – BT下载与分享</A>
<DT><A HREF="https://www.urlgot.com/zh_CN/" target="_blank" rel="noopener" >urlgot视频解析,下载器 for bilibili,Youtube ...</A>
<DT><A HREF="http://www.jspoo.com/vip.html" target="_blank" rel="noopener" >vip解析-全网在线视频解析、音乐解析、短视频解析_聚神铺</A>
<DT><A HREF="https://www.ttky8.com/" target="_blank" rel="noopener" >首页 | 天天看影吧</A>
<DT><A HREF="http://www.925.tv/" target="_blank" rel="noopener" >925直播-JRS直播,足球直播,NBA直播吧,低调看直播</A>
<DT><A HREF="https://hao.su/908/" target="_blank" rel="noopener" >bt磁力搜索网站 - 不死鸟 - 分享为王</A>


<h1 id="网站建设"><a href="#网站建设" class="headerlink" title="网站建设"></a>网站建设</h1><DT><A HREF="http://me.com/" target="_blank" rel="noopener" >WordPress站点</A>
<DT><A HREF="http://me.com/wp-admin/" target="_blank" rel="noopener" >后台</A>
<DT><A HREF="https://www.natfrp.com/?page=panel&module=download" target="_blank" rel="noopener" >管理面板 :: Sakura Panel - 内网穿透管理面板</A>
<DT><A HREF="https://promotion.aliyun.com/ntms/mobile.html" target="_blank" rel="noopener" >阿里云APP - 移动管控运维，云端资源尽在掌握</A>
<DT><A HREF="https://club.aliyun.com/?spm=5176.2020520207.0.0.13764c12Jq8QTG#/earnPoints?_k=ngg72u" target="_blank" rel="noopener" >会员俱乐部</A>
<DT><A HREF="https://dc.console.aliyun.com/next/index#/domain/list/all-domain" target="_blank" rel="noopener" >域名控制台</A>
<DT><A HREF="https://coding.net/" target="_blank" rel="noopener" >CODING - 一站式软件研发管理平台</A>
<DT><A HREF="https://blog.csdn.net/anqiao6759/article/details/101358857" target="_blank" rel="noopener" >使用hexo+coding搭建免费个人博客_anqiao6759的博客-CSDN博客</A>
<DT><A HREF="https://blog.csdn.net/qq_33619378/article/details/81191564" target="_blank" rel="noopener" >基于hexo和coding免费搭建个人博客网站_LarsCheng&#39;s Blog-CSDN博客</A>
<DT><A HREF="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener" >Hexo博客优化之Next主题美化_huangpiao-CSDN博客</A>
<DT><A HREF="https://homepea7.github.io/" >Welcome to GitHub Pages | Homepea7.github.io</A>
<DT><A HREF="https://homepea.coding.net/admin/overview" target="_blank" rel="noopener" >团队概览 - 团队帐户 - homepea</A>
<DT><A HREF="https://juejin.im/post/5b3ed1d4e51d45194e0b7884" target="_blank" rel="noopener" >Hexo+Github建站 - 掘金</A>
<DT><A HREF="https://www.jianshu.com/p/f60c60773fa8" target="_blank" rel="noopener" >Hexo + GitHub 建站最详细教程 - 程序员还是写作爱好者都可以拥有这样一个个人站 - 简书</A>
<DT><A HREF="https://juejin.im/post/5b3ed1d4e51d45194e0b7884#heading-36" target="_blank" rel="noopener" >Hexo+Github建站 - 掘金</A>
<DT><A HREF="https://dc.console.aliyun.com/next/index?accounttraceid=81133a8c9e95433a979838bdf42feab0wfkp#/domain/list/all-domain" target="_blank" rel="noopener" >域名控制台</A>
<DT><A HREF="https://github.com/Homepea7" target="_blank" rel="noopener" >Homepea7</A>
<DT><A HREF="https://github.com/" target="_blank" rel="noopener" >GitHub</A>
<DT><A HREF="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener" >Markdown基本语法 - 简书</A>
<DT><A HREF="https://zhuanlan.zhihu.com/p/94038688" target="_blank" rel="noopener" >hexo next 主题进阶设置 - 知乎</A>
<DT><A HREF="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener" >应用列表 - LeanCloud</A>
<DT><A HREF="https://sphard.com/ebooks/hexo-next-2/" target="_blank" rel="noopener" >本书简介 · Hexo博客+Next主题教程 | SPhard</A>
<DT><A HREF="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener" >Font Awesome Icons</A>
<DT><A HREF="https://analytics.google.com/analytics/web/#/report-home/a157890086w222126945p211052566" target="_blank" rel="noopener" >Google Analytics（分析）</A>
<DT><A HREF="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener" >hexo-helper-live2d/README.zh-CN.md at master · EYHN/hexo-helper-live2d</A>
<DT><A HREF="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener" >hexo live2d插件 2.0 ! | 幻想帖</A>


<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>东西比较乱，主要是自己看的，所以没有好好整理，主要是东西收藏的太多了，分类的时候有一些都没有好好注意，本来想弄成表格，但是太乱了不好做，只能这样将就看看了<del>~</del></p>
]]></content>
  </entry>
</search>
